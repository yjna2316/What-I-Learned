# Part1-2 Computer Architecture

* [메모리](#메모리) 
  * [메모리 계층 구조](#메모리-계층-구조)
* [캐시 메모리](#캐시-메모리)
  * [개요](#개요)  
  * [적중과 실패](#적중과-실패)
  * [캐시 메모리 기본 구성과 동작](#캐시-메모리-기본-구성과-동작)
  * [블록사상](#블록사상)
    * [직접 사상](#직접-사상)
    * [완전 연관](#완전-연관-사상)
    * [집합 연관 사상사상](#집합-연관-사상)
  * [블록 교체](#블록-교체)
  * [블록 갱신](#블록-갱신)
  * [캐시와 성능](#캐시와-성능)
* [References](#reference)

접근 방향: 내가 못된 사장님, cpu는 알바생, 사장님은 알바생을 돈을 준만큼 그 이상으로 최대한 부려먹기위해 어떻게 해서든 못 쉬게 머리를 굴림. 사장의 입장에서 바라보면 이해하기 쉬울것같다. 

## 메모리
### 메모리 계층 구조
컴퓨터 사용자는 누구나 더 큰 용량, 더 빠른 속도, 더 저렴한 가격의 메모리를 원한다. 하지만 메모리의 용량은 클수록 속도가 느려지고, 속도가 빠를수록 가격이 비싸져 이 세가지 요소는 서로 상충한다. 이를 극복하고자 메모리 계층 구조를 사용한다. 메모리 계층 구조란 속도와 가격, 용량이 서로 다른 메모리들을 계층적으로 설치해 가격 대비 성능을 높이는 구성 방식이다. 소용량의 빠른 메모리를 CPU에 가깝게 배치하고, 느리지만 대용량의 메모리를 CPU에 멀리 배치하고, 서로 인접한 계층에서만 데이터(복사본)를 전송하며, 계층간의 데이터 전송 단위가 서로 다르다.


* 메모리 계층 구조 동작 과정[그림]
![메모리 계층 구조 동작 과정](https://github.com/yjna2316/What-I-Learned/blob/master/ComputerArchitecture/media/cache_data_transfer_unit.JPG)


## 캐시 메모리
### 개요
CPU는 데이터를 처리하기 위해 메모리(주기억장치)에서 데이터를 가져오고, 처리한 데이터를 메모리에 저장해야 한다. 그러나 메모리는 CPU에 비해 속도가 매우 느리기 때문에 메모리에 접근할 때마다 CPU는 많은 시간을 기다리게 되고(=노는 시간이 많다) 시스템 성능은 저하된다. 따라서, **CPU의 메모리 접근 시간을 단축시키기 위해 속도가 빠른 캐시 메모리를 사용한다.** 이를 위해서는 **적중률**(CPU가 요청한 데이터가 캐시에 있을 확률)을 높여야 한다. 적중률을 위해 **지역성의 원리**를 이용하지만 프로그램마다 지역성이 다르기 때문에 한계가 있다. 따라서 캐시 적중률 최대화, 캐시 접근 시간 최소화, 주기억장치로부터 캐시로 정보 읽어오는 시간 최소화, 캐시 내용 변경시 주기억장치 내용 갱신 시간 최소화에 신경써서 캐시를 설계해야 한다.


그렇다면 캐시메모리란 무엇인가? CPU의 메모리 접근 시간을 단축시키기 위해 데이터를 잠깐 저장해주는 중간 버퍼 기능을 하는 고속 저용량 메모리이다. 캐시는 CPU 와 인접한 곳에 배치하거나 CPU 칩 내부에 포함된다. 하지만 CPU **가까이에** CPU가 **자주 사용하는 내용**들이 캐시에 저장되어 있다면, 주기억장치에 접근하지 않고 더 신속하게 처리할 수 있게 된다.(만약 캐시를 사용하지 않았다면, CPU는 매번 필요한 데이터를 가져오기 위해 시간이 오래 걸리는 주기억장치에 접근해야 한다.)

[캐시 메모리 기본 동작 과정]
(그림)

### 적중과 실패
캐시는 어떤 기준으로 데이터들을 가져오는 것일까? 바로 **지역성**을 이용한다. 지역성이란, 짧은 시간 동안 CPU가 기억장치의 특정 부분을 빈번하게 접근하는 현상을 말한다. 그 이유는, 일반적으로 프로그램이 반복문과 서브루틴(함수 호출)을 포함하고 있어, 반복문이 수행되거나 빈번히 호출되는 서브루틴이 있다면, 그들이 저장되어 있는 작은 영역이 집중적으로 접근될 것이기 때문이다. 따라서 다음과 같은 지역성들 때문에 캐시에 적재되어 있는 정보들이 그 후에 CPU에 의해 다시 사용되는 경우가 많게 된다. 지역성의 원리에는 다음 두가지 종류가 있다.

  * 시간적 지역성

    최근에 참조된 명령어나 데이터가 가까운 미래에 다시 참조되는 경향. ex) 반복문의 경우, 방금 사용한 명령어와 데이터가 곧 다시 사용된다.  
  
  * 공간적 지역성
  
    최근에 참조된 명령어나 데이터에 인접한 데이터들이 다시 참조되는 경향. ex) 배열을 순회할 때

캐시의 성능은 적중률(CPU가 요청한 데이터를 캐시에서 찾을 확률)에 비례한다. 원하는 내용이 캐시에 있으면 적중(hit), 없으면 실패(miss)라 한다.


캐시 메모리의 기본 동작 과정<그림 첨부>

캐시 메모리는 고가이기에 적은 용량을 사용해 캐시에 저장될 수 있는 데이터는 한정 된다. 따라서, 캐시에 어떤 내용을 어디에 배치하고, 공간 부족시 어떤 내용을 교체할 것이지, 변경이 일어날 경우 원본은 언제 갱신할 건지 등을 고려해 캐시를 설계해야한다. 이에 대한 전력들로 블록 사상 방식, 블록 교체 방식, 블록 갱신 방식이 있다. 이에 앞서 먼저 캐시 메모리의 기본 구성과 동작에 대해 알아보자.

### 캐시 메모리 기본 구성과 동작
CPU는 캐시에 필요한 정보가 있는지 어떻게 확인할까? 바로 **태그**를 비교한다. 캐시 메모리는 CPU가 요청한 데이터를 가지고 있는지 확인하기 위해 **태그**를 사용하는데 일치하는 태그가 있으면 해당 데이터를 CPU에게 보내고, 없으면 메모리에서 데이터를 복사해와 캐시에 저장하고 CPU에게 보내준다. 



먼저 캐시 메모리의 구성에 대해 알아보자. 캐시 메모리는 태그 메모리와 데이터 메모리로 구성된다. 데이터 메모리는 데이터 블록으로 구성되어 있고, 블록은 캐시와 메모리 간 데이터 전송 단위이다. 태그 메모리는 각 데이터 블록의 정보와 CPU 주소와 태그를 비교하는 비교기를 가지고 있다.

[그림] 캐시 기본구성

태그: CPU가 요청한 블록을 탐색하는데 사용하는 주소 정보의 일부이다.

유효비트: 캐시 블록이 유효한 데이터인지 아닌지를 나타낸다.

갱신비트: 메모리에서 캐시로 블록을 가져온 후 부터 CPU가 블록을 수정했는지 아닌지를 나타낸다.

#### 캐시 메모리 기본 동작 과정
CPU가 참조하려는 데이터 주소를 캐시 메모리에 보내면 캐시 메모리는 대응하는 데이터를 포함하는지 자신의 태그 메모리를 탐색한다. 이때 캐시 태그와 CPU 태그를 비교하여 일치하는 태그가 있다면 캐시 적중. 데이터 메모리에 있는 캐시 블록에 접근하여 원하는 워드를 추출하고 CPU로 전송한다. 필요할 경우, 블록 갱신 방식에 따라 참조된 블록의 갱신 비트를 사용해 어느 블록이 수정되었는지 나타낸다.

하지만, CPU 태그와 일치하는 캐시 태그가 없다면 캐시 실패이므로, 캐시는 캐시 실패 신호를 CPU에게 보내고, CPU는 메모리에서 원하는 블록을 가져와 캐시의 데이터 메모리에 복사하고, 대응하는 태그를 갱신한 후 원하는 워드를 사용한다. 


### 블록 사상 
캐시는 메모리보다 용량이 작기 때문에 다수의 메모리 블록이 하나의 캐시 블록을 공유해야 한다. 따라서 메모리 블록을 캐시 안에 어떻게 배치할 것인가 하는 문제가 발생하는데 이에 대한 전략으로 블록 사상 방식(=블록 배치 방식)을 이용한다. 이때 블록을 어떻게 배치하느냐에 따라 캐시 적중률(성능)에 많은 영향을 미친다. 블록 사상 방식은 **메모리에서 읽은 블록이 저장될 캐시 위치를 결정하는 방법**으로 직접 사상, 완전 연관 사상, 집합 연관 사상이 있다.

**1. 직접 사상**
모듈로 연산을 이용해 저장할 위치를 계산하는 방법으로 하나의 캐시 블록에만 메모리 블록을 배치할 수 있다.
모듈로(modulo) 연산을 이용해서 메모리 블록을 정해진 하나의 캐시 블록에만 배치하는 방식이다. 즉, 메모리 블록 번호를 캐시 블록 개수로 나눈 나머지 값에 대응하는 캐시 블록에 사상하는 방식이다. CPU가 주소를 생성해 캐시에 데이터를 요청하면, 캐시 메모리는 이 주소를 CPU 태그, 인덱스, 블록 오프셋으로 분할한다. 인덱스 필드가 가리키는 캐시 메모리의 태그를 추출하고, 

태그의 길이가 짧고, 하드웨어 구현이 단순하며, 접근 속도가 빠르지만, 동일한 캐시 블록에 사상되는 태그가 다른 블록이 번갈아 자주 참조 된다면 충돌이 일어나 적중률이 낮아진다.

**2. 완전 연관 사상**

메모리 블록을 캐시 블록 아무곳이나 배치할 수 있다.

**3. 집합 연관 사상**

직접 사상과 완전 연관 사상을 절충한 방법으로, 메모리 블록을 지정된 한 그룹으로만 배치될 수 있으며, 그 그룹 안에서는 어디든 배치할 수 있다.

캐시에 원하는 데이터가 있는지 어떻게 확인할까? 태그를 사용한다.
먼저 캐시 메모리는 ~로 구성된다.(그림첨부) 
메모리에서 가져온 내용을 캐시 안에 저장할 때 어떤 원리로 저장을 하게 될까? 공간이 없다면?

### 블록 교체 방식
캐시 실패가 발생하고 캐시 메모리에 빈 공간이 없을 때 사용중인 캐시 블록 중 어느 것을 교체할지 결정하는 방식으로 다음의 알고리즘들을 통해 결정한다.

**대표적인 알고리즘**

**1. LRU(Least Recently Used)** 캐시 내에서 가장 오랫동안 참조되지 않은 블록을 교체하는 방식으로 적중률이 높음.

**2. FIFO(First In First Out)** 캐시 내에서 가장 오래동안 있었던 블록을 먼저 교체하는 방식. 

**3. LFU(Least Frequency Used)** 사용된 빈도가 가장 낮은 블록을 교체하는 방식.

### 블록 갱신 방식
캐시에서 데이터가 수정되면 메모리에도 반영하여 캐시와 메모리의 데이터를 일치시켜야 하는데, 이를 블록 갱신 또는 블록 쓰기 방식이라 한다. 캐시 내용을 메모리와 일치시키는 시점에 따라 다음 두가지로 나뉜다. 

**1. Write Through (즉시 쓰기)**
모든 쓰기 동작들이 캐시와 주기억장치 모두 동시에 행해진다. 따라서 주기억장치의 내용들은 항상 유효(캐시 내용과 같다)하지만, 쓰기 동작을 할 때마다 메모리를 수정해야 하므로 속도가 느려진다는 단점이 있다.
 
**2. Write Back (나중 쓰기)**
수정된 캐시 블록이 교체될 때 메모리에 반영하는 방식으로, 수정 여부를 표시하기 위해 갱신 비트를 사용한다. 결과적으로 기억장치에 대한 쓰기 동작 횟수가 최소화 되므로 쓰기 속도가 빨라진다. 하지만, 입출력 장치가 데이터를 요청할 때 캐시와 메모리 중 어느 곳이 유효한 데이터를 제공할 수 있는지 살펴야 한다.    

## References
* 생능출판사, 컴퓨터구조론
* 한빛아카데미, 컴퓨터 아키텍처 컴퓨터 구조 및 동작 원리

