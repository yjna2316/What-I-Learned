# Part1-1 DataStructure
* [Priority Queue](#priority-queue)
  * [Heap](#heap)
  * [Heap Sort](#heap-sort)
* [HashTable](#hash-table)
  * [Collision]

* [References](#reference)

## Priority Queue
우선순위 개념을 큐에 도입한 자료구조로, **우선순위가 높은 데이터 순으로 삭제**된다. 배열, 연결리스트, 힙 등을 통해 구현할 수 있으며, 힙(heap)이 가장 효율적이다. 

Array\
*Unsorted* 삽입할 경우, 맨 끝에 붙인다 O(1). 삭제할 경우, 가장 우선순위가 높은 원소를 찾아서 삭제해야 하므로 원소들을 처음부터 끝까지 스캔 O(N). 삭제 후 뒤에 있는 요소들을 앞으로 이동시켜야 한다. *Sorted* 삽입할 경우, 일일이 다른 원소와 비교하여 우선순위에 따라 삽입할 위치를 결정해야 한다. 삽입 위치를 찾은 다음, 뒤에 있는 요소들을 뒤로 이동시켜야 한다 O(N). 삭제는 큰 수의 우선순위가 높다고 가정할 경우 맨 뒤에 위치한 요소를 삭제한다 O(1).

Linked List\
*Unsorted* 삽입할 경우, 첫번째 노드로 삽입한다 O(1). 삭제시, 링크필드를 따라서 모든 노드를 스캔해야 한다 O(N). 배열과 달리 다른 노드를 이동시킬 필요가 없다. *Sorted* 우선순위가 높은 요소가 앞에 위치하는 것이 유리하다. 삽입 시 첫번째 노드부터 순차적으로 비교해가면서 위치를 찾아야 하므로 O(N). 삭제는 첫 번째 노드를 삭제하면 되므로 O(1).

Heap\
삽입시, 새로운 요소가 히프 트리를 타고 올라가면서 부모 노드들과 교환을 하게 되는데, 최악의 경우 루트 노드까지 올라가야 하므로 트리 높이만큼 시간이 걸린다. 히프는 완전 이진 트리이므로 히프의 높이는 logN이다 O(logN). 삭제도 마찬가지로 마지막 노드를 루트로 가져온 후, 자식 노드들과 비교하며 내려가고 최악의 경우 가장 아래 레벨까지 내려가야하므로 트리 높이만큼 시간이 걸린다 O(logN).

| Representations      | Insert  | Delete  |
| -------------------- |:-------:|:-------:|
| Unsorted Array       | O(1)    | O(N)    |
| Unsorted Linked List | O(1)    | O(N)    |
| Sorted Array         | O(N)    | O(1)    |
| Sorted Linked List   | O(N)    | O(1)    |
| Heap                 | O(logN) | O(logN) |
\
\
\
## Heap
배열에 기반한 완전이진트리로 최대/최소값 탐색에 용이하다. 즉,부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 작은 이진트리를 말한다. Heap은 완전 이진 트리이기 때문에 배열로 구현 가능하며, 0이 아닌 1번 index부터 루트노드가 시작된다. 노드의 고유번호 값과 배열의 index를 일치시켜 계산상 혼동을 줄이기 위함이다 Heap에는 최대힙(max heap), 최소힙(min heap) 두 종류가 있다.

MaxHeap에서는 부모가 자식보다 항상 크거나 같다. 따라서 Root Node에 가장 큰 값이 위치하며(최소힙은 반대, RootNode에 최소값위치), 최대값을 찾는데 걸리는 시간은 O(1)이다. 새 노드를 삽입하거나 삭제하는데 걸리는 시간은 O(logN)이다. 이는 Heap 구조를 유지시켜야 되기 때문에 삽입 / 삭제 발생시 각 노드들의 위치를 조정하는데, 최악의 경우 트리 높이 만큼 비교 연산을 해야하기 때문이다(heapify). 

cf. Binary Search Tree는 중복을 허용하지 않으나, Heap에서는 중복을 허용한다.

\
### Heap Sort
N개의 요소를 정렬할 경우 O(NlogN)이 소요된다. 정렬해야 할 N개의 요소들을 최대 힙으로 초기화한다. 그 다음, 하나씩 요소를 힙에서 꺼내 배열의 뒤부터 저장한다. 하나의 요소를 Heap에 삽입하거나 삭제할 때 Heap을 재정비하는 시간이 logN만큼 소요되고, 전체 요소 개수가 N개이므로 O(NlogN)이 걸린다. 힙 정렬은 **전체 자료를 정렬하는 것이 아니라 가장 큰(작은) 값 몇 개만 필요할 때** 유용하다.
\
\
\
## Hash Table
해시 테이블 또는 해시 맵은 key와 value를 하나의 쌍으로 갖는 자료구조이다. 주요 동작은 key값으로 원하는 value값을 찾는 것인데 key값을 인덱스로 사용하는 것이 아니라, hash function을 이용해 주어진 key값을 hash값으로 변환하고, 이 **hash값을 인덱스**로 하여 원하는 값이 있는 버킷을 찾아낸다. 현실적으로 탐색 키들이 문자열이거나 매우 큰 숫자이기 때문이다. 따라서, 각 *탐색 키를 작은 정수로 맵핑* 시켜야하며, 이 역할은 hash function이 해준다. 해시 테이블은 배열로 구현한다.

*Hashing* 해시테이블을 이용한 탐색. 탐색 키만 가지고 항목이 저장되어 있는 배열의 *인덱스를 결정*하는 기법이다. 


### 시간 복잡도와 용도
key에 대한 데이터를 찾을 때, hash function을 한번만 수행하면 array내에 저장된 index 위치를 바로 찾아낼 수 있기 때문에, 데이터 저장과 삭제, 검색 속도가 빠르다. 특정 값을 탐색할 때, 인덱스로 접근하므로 평균적으로 시간 복잡도는 O(1). 충돌 때문에 최악의 경우 검색 시간은 O(N).

hash table 검색 성능은 해시 함수의 성능과 테이블 크기에 좌우된다. 충돌이 발생하면 할수록 성능은 점점 O(n)에 가까워지므로 충돌을 최대한 억제시키는 것이 해쉬의 핵심 포인트다.


### Hash Function
좋은 해시 함수란, 데이터를 되도록이면 고르게 분포하여, 충돌을 최소화 할 수 있는 함수이다. 해시테이블의 get(key)와 put(key)에 Cache 로직을 추가하게 되면, 자주 hit하는 데이터에 대해서 바로 데이터를 찾게 함으로써, 성능을 향상 시킬 수 있다. 

서로 다른 키가 동일한 위치(인덱스)로 해싱되었을 때 충돌이 발생한다. 따라서 해싱된 인덱스에 이미 다른 값이 들어 있다면, 저장할 수 있는 다른 위치를 찾아야 한다.

### Resolve Collision

#### 1. Seperate Chaining 방식
* 연결 리스트를 사용하는 방식\
  각 버킷들을 Linked List로 만들어 충돌 발생시 해당 버킷에 노드를 추가하는 방식이다. 각 index에는 데이터가 저장되어 있는 Linked List에 대한 포인터가 들어있다. 삽입: O(n)

  데이터를 검색하고자 할 때는, key에 대한 index를 구한 후, index가 가리키고 있는 Linked List를 선형 검색하여, 해당 key에 대한 데이터가 있는지 검색하여 리턴한다. 검색: O(n) 삭제 또한, key에 대한 index가 가리키고 있는 Linked List에서, 해당 노드를 삭제하면 된다. 삭제: O(n)

  
* Tree를 사용하는 방식\
  각 버킷들을 Linked List 대신 Tree(Red-Black)를 사용하는 방식이다. Tree를 이용해 저장함으로써, select(검색) 성능을 높일 수 있다. 검색: O(logn) 하지만, 트리는 기본적으로 메모리 사용량이 많고, 데이터 개수가 적을 때 트리와 리스트 성능 상 차이가 거의 없으므로, 메모리 측면에서 보았을 때 데이터 갯수가 적으면 링크드 리스트를 사용한다. JDK 1.8 기준으로 index에 노드가 8개 이하일 경우 Linked List 사용.


#### 2. Open Address 방식
Index에 대한 충돌 처리에 대해서 Linked List와 같은 추가 메모리를 사용하지 않고, hash table array의 빈공간을 사용하는 방법으로, Seperate Chaining 방식에 비해서 메모리를 덜 사용한다.

* Linear Probing: Index에 대해서 충돌 발생시, index 뒤에 있는 버킷 중 빈 버킷을 찾아 데이터를 넣으며, 순차적으로 탐색한다.

* Quadratic Probing: 2차 함수를 이용해 탐색할 위치를 찾는다.

* Double Hashing Prbing: 하나의 해시 함수에 의해 충돌이 발생하면 2차 해시 함수를 이용해 새로운 주소를 할당 받는 방법이다. 가장 많은 연산량을 요구한다.

탐사 방식에 따라 해시 성능이 달라지지만, 가장 영향을 미치는 요소는 해시 테이블의 load factor(전체 슬롯 중에서 사용중인 슬롯 비율)이다. load factor가 증가할 수록 데이터를 찾거나 삽입하기 위해 필요한 탐사 횟수는 비약적으로(dramatically) 증가한다. 


해싱 vs 이진 탐색 트리
이진 탐색 트리는 현재 값보다 다음으로 큰 값(작은 값)을 쉽게 찾을 수 있으며, 정렬되어 있으므로 값의 크기순으로 순회하는 것이 쉽다. 반면 해싱은 순서가 없기 때문에 정렬이 불가, 테이블 크기를 얼마만큼 할당해야 되는지가 불명확하다. 최악의 경우 모든 값이 하나의 버켓으로 집중되는 것으로 이 경우 시간 복잡도가 O(N)이 된다.


### References 
http://bcho.tistory.com/m/1072?category=617037

http://sweeper.egloos.com/m/925740




## References 
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure 

http://cs.lmu.edu/~ray/classes/dsa/ 

C언어로 쉽게 풀어쓴 자료구조
