# Part1-1 DataStructure
* [Array vs ArryaList vs LinkedList](#Array-vs-ArryaList-vs-LinkedList)
* [Stack and Queue](#stack-and-queue)
* [Sort](#sort)
* [Priority Queue](#priority-queue)
  * Heap
  * Heap Sort
* [Tree](#tree)
  * Binary Tree
  * Binary Search Tree
  * AVL Tree
  * Red Black Tree
* [HashTable](#hash-table)
  * Hash Function
  * Collision Resolution
  * Resizing
* [References](#reference)

--------------------------------------------------------------
## Array vs ArryaList vs LinkedList
### Array
논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조로 index를 통해 상수시간만에 데이터 접근이 가능하다.하지만, 삽입/삭제시 뒤에 있는 모든 원소들을 앞/뒤로 옮겨야하기 때문에 O(n)의 시간이 걸린다. 배열의 연속적인 특징을 만족시켜야 하기 때문이다.

* 장점: random access 모든 원소의 접근 O(1)으로 동일 (메모리 상의 주소를 정확하게 참조해서 가져오기 때문)
* 단점: 크기고정, 삽입/삭제시 원소 이동 오버헤드 발생
* 언제사용? 데이터 크기 예상 가능할 때 -> 메모리 동적 할당 필요 없이 주어진 공간내에서 사용할 수 있으므로 메모리나 처리속도 면에서 효과적
* index 조회 O(1), 삽입/삭제 O(N)

cf. Java에서 배열이 저장되는 메모리 영역은 Heap

### List
배열에서 원소 삭제시 공간 낭비의 단점을 보완해서 List 내부에 빈틈이 없게 만든, 값 간의 순서가 유지되는 자료구조이다. 중간에 데이터를 추가하면 해당 인덱스의 값에 새로운 값으로 overwrite되고, 삭제하면 배열에서는 빈자리가 그대로 남아있지만 List에서는 그 빈자리를 채우기 위해 뒤 데이터를 당기거나 밀어버린다. 즉, 순서가 유지되고 Set과 달리 중복이 허용된다.

List의 기능
* 처음, 끝, 중간에 엘리먼트를 추가/삭제하는 기능
* 리스트에 데이터가 있는지를 체크하는 기능
* 리스트의 모든 데이터에 접근할 수 있는 기능

**LinkedList vs ArrayList**\
* 내부적인 구현 방법이 다르다: Linked, Array
* 언제 사용? 
  * ArrayList: 인덱스 접근이 빈번할 때 / 순차적으로 추가/삭제시
  * LinkedList: 데이터 추가/삭제가 빈번 / 비순차적으로 추가/삭제시

#### ArrayList
배열을 이용해 구현한 것으로, 인덱스 접근이 가능해 조회가 빠르고 데이터의 추가/삭제는 느리다. 고정된 크기의 배열과 달리, 동적 배열이라 선언시 크기 지정 안해도 된다.

#### LinkedList
데이터와 링크로 구성된 자료구조로 원소간의 연결(link)을 이용해 리스트를 구현한 것이다. 배열과 달리, 논리적 저장 순서와 물리적 저장 순서가 일치하지 않아 탐색시 O(n)이 걸리고(순차적 접근), 삽입/삭제는 링크만 변경하면 되므로 O(1)이 걸린다.

* 장점: 크기 고정 x, 추가/삭제 빈번시 용이
* 단점: 링크 필드에 대한 추가공간 필요. 
* 언제사용? 삽입/삭제가 빈번할 때, Tree 구현시
* 시간 복잡도
  * 탐색: O(N)
  * 삽입/삭제: 최선 O(1) 최악 O(N)


각 노드들은 자기 다음에 어떤 노드가 오는지 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제/삽입을 O(1)만에 할 수 있다. 하지만, 특정 위치에 삭제/삽입을 하고자 한다면 원하는 위치를 탐색하는 과정에서 첫번째 노드부터 순차적으로 접근하기 때문에 O(n) 시간이 추가적으로 발생한다.

------------------------------------------------------------
## Stack and Queue
### Stack
LIFO(Last In First Out) 구조로 나중에 들어온 원소가 먼저 나가는 자료구조이다. 스택은 함수 호출에 사용되는데, 호출이 끝나고 호출한 함수의 주소로 되돌아가기 위해 필요하다.

### Queue
FIFO(First In First Out) 구조로 먼저 들어온 원소가 먼저 나가는 자료구조이다. 참고로 Java Collection에서 Queue는 인터페이스이다.

### Circular Queue
선형 큐는 삭제된 공간을 재사용하지 못하기 때문에 공간 낭비가 발생한다. 빈 공간을 사용하기 위해 원소들을 앞으로 옮기는 방법이 있지만, 모든 데이터들을 이동시켜야 하기에 비효율적이다. 또한 한정된 메모리에서 큐를 계속 사용하면 메모리 초과가 날 수 있다. 따라서, 큐의 단점을 보완하기 위해 큐의 맨 끝과 처음이 연결된 형태의 자료구조가 원형큐이다. 원형큐는 공간을 재사용할 수 있기 때문에 고정된 크기의 메모리를 사용해야 될 경우 사용된다.

------------------------------------------------------------------------------
## Sort

### Selection Sort 
* n개의 원소 배열을 정렬할 때, 최솟값을 찾아 맨 앞의 값과 교환. 맨 처음 원소를 뺀 나머지 원소 n-1개에 대하여 최소값을 찾아 2번째 원소와 자리 교환. 맨 처음 2개의 원소를 뺀 나머지 원소 n-2에 대하여 같은 과정 반복  

### Insertion Sort
* n개의 원소 배열을 정렬할 때, 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬된 부분과 차례대로 비교하여 적절한 위치를 찾아 삽입하는 방법
* k번째를 정렬할 순서라고 가정하면, 0부터 k-1까지의 원소드른 정렬되어있다는 가정하에, k번째 원소를 k-1번째 원소를 시작으로 0번째 원소까지 차례대로 비교하면서 k번째 원소가 비교하는 원소보다 작을 경우 비교하는 원소를 오른쪽으로 한 칸씩 이동, 비교하는 원소보다 크면 그 원소 바로 다음 위치에 삽입.

정렬된 경우 O(n), 역순 O(n^2)

### Bubble Sort
* n개의 원소 배열을 정렬할 때, 인접한 두 원소를 비교하면서 정렬하는 방법. 가장 큰 값을 배열의 맨 끝에다 이동시키면서 정렬시키게 된다.

O(n^2) 가장 느림, 단순

### Merge Sort
* 하나가 남을 때까지 균등한 크기로 분할한 후, 정렬하면서 다시 합치는 방법 
* Divide and Conquer 방식

O(nlogn) time, O(n) space

### Quick Sort
* 피봇을 중심으로 좌우로 나누고 정렬하는 방법으로, 왼쪽에는 피봇보다 작은 값을 오른쪽에는 피봇보다 큰 옮긴다. 
* Divide and Conquer 방식
* O(nlogn): 리스트 분할이 가운데서 이루어질 때 
* O(n^2): 역순 또는 정렬된 경우 분할이 불균형하게 나뉘거나 pivot값이 항상 가장 큰/작은 값일 때

[code](https://github.com/yjna2316/What-I-Learned/blob/master/DataStructure/Sort/Sort.java)

Algorithm | (average) Time Complexity | (worst) Time Complexity | Space Complexity
:----------:|:----------:|:---------: |:---------: 
Selection Sort | O(N^2) | O(N^2) | O(1)
Insertion Sort | O(N^2) | O(N^2) | O(1)
Bubble Sort | O(N^2) | O(N^2) | O(1)
Merge Sort | O(NlogN) | O(NlogN) | O(N)
Quick Sort | O(NlogN) | O(N^2) | O(1)
Heap Sort | O(NlogN) | O(NlogN) | O(1)

----------------------------------------------------------------
## Priority Queue
**우선순위가 높은 데이터 순**으로 꺼내는 자료구조로, 힙으로 구현시 힙에 집어넣을 땐 힙 구조를 만족시키기 위해 O(logN)이 걸리고 꺼낼땐 상수시간이 걸린다.

#### [code](/DataStructure/PriorityQueueAndHeap/PriorityQueue.java)

언제 사용
* 스케쥴링
* 최신 알람을 받아보고 싶을때

<!-- Array\
*Unsorted* 삽입할 경우, 맨 끝에 붙인다 O(1). 삭제할 경우, 가장 우선순위가 높은 원소를 찾아서 삭제해야 하므로 원소들을 처음부터 끝까지 스캔 O(N). 삭제 후 뒤에 있는 요소들을 앞으로 이동시켜야 한다. *Sorted* 삽입할 경우, 일일이 다른 원소와 비교하여 우선순위에 따라 삽입할 위치를 결정해야 한다. 삽입 위치를 찾은 다음, 뒤에 있는 요소들을 뒤로 이동시켜야 한다 O(N). 삭제는 큰 수의 우선순위가 높다고 가정할 경우 맨 뒤에 위치한 요소를 삭제한다 O(1).

| Representations       | Insert  | Delete  |
| --------------------- |:-------:|:-------:|
| Unsorted Array        | O(1)    | O(N)    |
| Sorted Array          | O(N)    | O(1)    | -->

<!-- 
Linked List\
*Unsorted* 삽입할 경우, 첫번째 노드로 삽입한다 O(1). 삭제시, 링크필드를 따라서 모든 노드를 스캔해야 한다 O(N). 배열과 달리 다른 노드를 이동시킬 필요가 없다. *Sorted* 우선순위가 높은 요소가 앞에 위치하는 것이 유리하다. 삽입 시 첫번째 노드부터 순차적으로 비교해가면서 위치를 찾아야 하므로 O(N). 삭제는 첫 번째 노드를 삭제하면 되므로 O(1).

| Representations       | Insert  | Delete  |
| --------------------- |:-------:|:-------:|
| Unsorted Linked List  | O(1)    | O(N)    |
| Sorted Linked List    | O(N)    | O(1)    | -->

### Heap
배열에 기반한 완전이진트리로 최대/최소값 탐색에 용이하다. 즉,부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 작은 이진트리를 말한다. Heap은 완전 이진 트리이기 때문에 배열로 구현 가능하며, 0이 아닌 1번 index부터 루트노드가 시작된다. 노드의 고유번호 값과 배열의 index를 일치시켜 계산상 혼동을 줄이기 위함이다 Heap에는 최대힙(max heap), 최소힙(min heap) 두 종류가 있다.

MaxHeap에서는 부모가 자식보다 항상 크거나 같다. 따라서 Root Node에 가장 큰 값이 위치하며(최소힙은 반대, RootNode에 최소값 위치), 최대값을 찾는데 걸리는 시간은 O(1)이다. 새 노드를 삽입하거나 삭제하는데 걸리는 시간은 O(logN). 이는 Heap 구조를 유지시켜야 되기 때문에 삽입 / 삭제 발생시 각 노드들의 위치를 조정하는데(heapify), 최악의 경우 트리 높이 만큼 비교 연산을 해야하기 때문이다.

cf. Binary Search Tree는 중복을 허용하지 않으나, Heap에서는 중복을 허용한다.

구현
* 삽입: 새 원소를 배열의 맨끝에 위치시킨 후 부모 노드들과 비교 및 교환하면서 히프 트리를 타고 올라간다. 최악의 경우 루트 노드까지 올라가야 하므로 트리 높이만큼 시간이 걸린다.
* 삭제: 마지막 노드를 루트로 가져온 후, 자식 노드들과 비교하며 내려가고 최악의 경우 가장 아래 레벨까지 내려가야하므로 트리 높이만큼 시간이 걸린다 O(logN).

| Representations       | Insert  | Delete  |
| --------------------- |:-------:|:-------:|
| Priority Queue (Heap) | O(logN) | O(logN) |



### Heap Sort
N개의 요소를 정렬할 경우 O(NlogN)이 소요된다. 정렬해야 할 N개의 요소들을 최대 힙으로 초기화한다. 그 다음, 하나씩 요소를 힙에서 꺼내 배열의 뒤부터 저장한다. 하나의 요소를 Heap에 삽입하거나 삭제할 때 Heap을 재정비하는 시간이 logN만큼 소요되고, 전체 요소 개수가 N개이므로 O(NlogN)이 걸린다. 힙 정렬은 **전체 자료를 정렬하는 것이 아니라 가장 큰(작은) 값 몇 개만 필요할 때** 유용하다.

--------------------------------------------------------------
## Tree
계층적 관계를 표현한 자료구조
* 용어: 노드, 단말(비단말) 노드, 차수, 레벨, 높이
* 차수: 어떤 노드가 가지고 있는 자식 노드 개수
* 레벨: 각 층별로 숫자를 매긴 것 0부터 시작
* 높이: 트리의 최고 레벨

### Binary Tree
모든 노드의 차수가 2이하인 트리로 노드가 없는 공집합도 이진 트리로 인정된다. 배열이나 연결리스트로 구현 가능하다.

조건 
  * 루트 노드를 중심으로 두 개의 서브 트리로 나뉜다.
  * 나뉜 두 서브 트리도 모두 이진 트리어야 한다.

분류
  * 포화이진트리 : 모든 레벨이 꽉찬 이진트리
  * 완전 이진 트리: 마지막 레벨에서는 노드가 꽉 차있진 않지만 중간엔 빈 틈이 없는 이진 트리 
  * 기타 이진 트리 : 나머지

사례
  * 구조화된 문서 출력
  * 폴더 용량 계산
  * 인덱스 구조

### Binary Search 
**정렬된 자료**에서 찾는 값을 가운데 값과 비교하여 탐색 범위를 절반으로 줄여나가는 방법. 배열에 저장된 데이터 탐색
* 동적으로 크기가 변하거나 삽입/삭제 빈번한 데이터 탐색에 부적합 / 정렬되어 있어야함
* 탐색: O(logN)
* 삽입/삭제: O(logN + N) (원소 이동 발생)

### BST(Binary Search Tree)
이진트리의 일종으로 효율적인 탐색을 위한 저장방법으로 다음 규칙에 따라 저장한다.

* 조건
1. 모든 노드의 키는 유일하다
2. 왼쪽 서브 트리의 키 < 루트 키
3. 루트 키 < 오른쪽 서브 트리 키  
4. 왼쪽 / 오른쪽 서브 트리도 이진 탐색 트리이다.

* 연결 리스트로 구현하여 삽입/삭제가 빈번할 때 사용 
* 균형트리일 경우 O(logN), 편향트리 O(N)
* 균형 트리임을 항상 보장하기 위해 삽입/삭제시 Rebalancing(트리 구조 재조정)을 하는 Red-Black Tree(RBT)와 AVL트리가 있다.

### AVL Tree
모든 노드의 양쪽 서브트리 높이차가 1이하인 이진 탐색트리로 삽입/삭제시 가까운 노드와 회전을 통해 rebalancing 한다.
  * 새로운 노드부터 균형 인수가 +-2인 가까운 조상 노드까지를 회전
  * O(logN) 탐색/삽입/삭제 
 
 ### Red-Black Tree

------------------------------------------------------------

## Hash Table

**Overview** Hash 함수를 이용하여 상수시간만에 읽기와 쓰기를 할 수 있는 자료구조로 key와 value값으로 저장된다. Hash 함수의 load balancing(hash값들이 고르게 분포되는 정도)에 따라 성능이 달라지며, 같은 값으로 해싱(키값이 해시함수에 의해 해시값으로 변환되는것)될 경우 충돌이 발생하게 된다. 충돌로 인해 탐색 시간이 길어져 table의 복잡도는 평균적으로 O(1)이지만 O(N)이 될 수 있다. 따라서 충돌을 최소화하기 위해 hash 함수는 데이터들을 고르게 분포해야 하며, 충돌 발생시 어떻게 대응 할 것인지도 생각해줘야 한다.


### Hash Function
Hash 함수는 어떤 알고리즘에 의해 key값을 hash값(연산 결과값)으로 변환해주는 역할을 하며, 이 hash값을 테이블의 인덱스로 사용하게 된다. Key값을 인덱스로 사용하지 않는 이유는, 보통 키는 문자열이거나 매우 큰 숫자인 반면에, 테이블 크기는 한정되어 필요한 범위의 수로 바꿔주어야 하기 때문이다.

좋은 hash 함수는 load balancing이 좋아야하며 이는 키의 어떤 특성을 가지고 해시값을 만들어 내느냐에 따라 달라진다. 또한 메모리상의 이유로 무조건 1:1로 만들어 충돌이 전혀 발생하지 않게 하는 것보단, 충돌을 최소화하는 방향으로 설계하는게 좋다. 간단한 방법의 예로, 키값을 테이블 크기(소수)로 나눈 나머지를 해시값으로 사용하는 방법 등이 있다.


### collision Resolution
충돌 발생시 이를 해결하는 방법으로, 사용할 수 있는 다른 위치를 찾는 방식(Open Address)과 테이블 구조 자체를 변경하여 한 위치에 여러 항목을 저장하는 방식(Seperated Chaining)이 있다.

**1. Open Address**
* Linear Probing
  비어있는 버킷이 나올 때까지 순차적으로 탐색한다.
* Quadratic probing
  2차 함수를 이용해 탐색할 위치를 찾는다.
* Double hashing probing
  2개의 hash 함수를 사용하는 방법으로, 충돌이 발생하면 다른 hash 함수를 이용해 새로운 주소를 할당한다. 위 두 가지 방법에 비해 많은 연산량을 요구하게 된다.

**2. Seperated Chaining**
* LinkedList를 사용하는 방식
  버킷을 linkedList로 만들어 충돌이 발생할 때 마다 해당 list에 추가하는 방식이다. 연결 리스트의 특성으로 삭제와 삽입이 간단하나, 포인터 필드에 대한 오버헤드가 있다.

* Tree를 사용하는 방식 (Red-Black Tree)
  linkedList와 tree 중 어떤 것을 사용할 것인가의 기준은 한 버킷에 할당된 (key, value) 쌍의 개수이다. 트리는 메모리 사용량이 많기 때문에 데이터 수가 적다면 linkedlist를 사용한다. 데이터가 적을 때 두 자료 구조의 성능상 차이는 거의 없으나, 메모리 측면에서 봤을 때 linkedList를 사용한다. 데이터 개수는 보통 8개를 기준으로 한다.

3. Open Address vs Seperated Chaining


### Resizing
Loadfactor(전체 버킷 중 사용 중인 버킷 비율)가 특정 임계점(JAVA는 0.75)을 넘게 되면, 테이블 확장이 일어나게 되는데, 더 큰 사이즈의 테이블로 데이터들을 옮긴다. 특정 임계점을 넘어가면 발생하는 급격한 성능 저하를 피하기 위함이다. 보통 2배 사이즈의 테이블로 옮기는데, 최종 메모리 크기가 N이라면 logN만큼만 확장을 수행하면 된다. 충돌이 일어나지 않는다면 n개의 원소들을 옮기는데 O(n)이 되지만, 충돌이 일어난다면 1개의 원소를 옮기는데 O(n)이 걸려 최악의 경우 O(n*n)이 된다.

**정리** 해시테이블은 빠른 읽기/쓰기가 가능하지만, 정렬 할 수 없고 테이블 확장시 비용이 많이 든다. 검색 성능은 해시 함수 성능과 테이블 크기에 좌우되며, 충돌 발생시 최악의 경우 O(n)이 되므로 충돌을 최소화 해야한다.

해싱 vs 이진 탐색 트리
이진 탐색 트리는 현재 값보다 다음으로 큰 값(작은 값)을 쉽게 찾을 수 있으며, 정렬되어 있으므로 값의 크기순으로 순회하는 것이 쉽다. 반면 해싱은 순서가 없기 때문에 정렬이 불가, 테이블 크기를 얼마만큼 할당해야 되는지가 불명확하다. 최악의 경우 모든 값이 하나의 버켓으로 집중되는 것으로 이 경우 시간 복잡도가 O(N)이 된다.

--------------------------------------------------------------------

## References 
* https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure 

* http://cs.lmu.edu/~ray/classes/dsa/ 

* 생활코딩
* 한빛미디어, C언어로 쉽게 풀어쓴 자료구조
