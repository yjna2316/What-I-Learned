# Part1 DataStructure
* [Priority Queue](#priority-queue)
* [Heap](#binary-heap)
  * [Heap Sort](#heap-sort)

* [References](#reference)

## Priority Queue
우선순위 개념을 큐에 도입한 자료구조로, **우선순위가 높은 데이터 순으로 삭제**된다. 배열, 연결리스트, 힙 등을 통해 구현할 수 있으며, 힙(heap)이 가장 효율적이다. 

### Representations
*Array* 
*Unsorted* 삽입할 경우, 맨 끝에 붙이면 되므로 O(1). 삭제할 경우, 가장 우선순위가 높은 원소를 찾아서 삭제해야 하므로 원소들을 처음부터 끝까지 스캔해야한다 O(N). 요소가 삭제된 다음, 뒤에 있는 요소들을 앞으로 이동시켜야 한다. *Sorted* 원소를 삽입할 경우, 일일이 다른 원소와 비교하여 우선순위에 따라 삽입할 위치를 결정해야 한다. 삽입 위치를 찾은 다음, 뒤에 있는 요소들을 뒤로 이동시켜야 한다 O(N). 그대신 삭제는 큰 수의 우선순위가 높다고 가정할 경우 맨 뒤에 위치한 요소를 삭제한다 O(1).

*Linked List*
*Unsorted* 삽입할 경우, 첫번째 노드로 삽입한다 O(1). 삭제시, 링크필드를 따라서 모든 노드를 스캔해야 한다 O(N). 배열과 달리 다른 노드를 이동할 필요가 없다. *Sorted* 우선순위가 높은 요소가 앞에 위치하는 것이 유리하다. 삽입 시 첫번째 노드부터 순차적으로 비교해가면서 위치를 찾아야 하므로 O(N). 삭제는 첫 번째 노드를 삭제하면 되므로 O(1).

*Heap*
삽입시, 새로운 요소가 히프 트리를 타고 올라가면서 부모 노드들과 교환을 하게 되는데, 최악의 경우 루트 노드까지 올라가야 하므로 트리 높이만큼 시간이 걸린다. 히프는 완전 이진 트리이므로 히프의 높이는 logN이다 O(logN). 삭제도 마찬가지로 마지막 노드를 루트로 가져온 후, 자식 노드들과 비교하며 내려가고 최악의 경우 가장 아래 레벨까지 내려가야하므로 트리 높이만큼 시간이 걸린다 O(logN).



## Heap
**가장 크거나 가장 작은 값을 빠르게 찾아내도로 만들어진** 자료구조로, 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다. Heap은 완전 이진 트리이기 때문에 배열로 구현 가능하며, 0이 아닌 1번 index부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 계산상 혼동을 줄이기 위함이다 Heap에는 최대힙(max heap), 최소힙(min heap) 두 종류가 있다.

MaxHeap에서 최대값을 찾는데 걸리는 Time Complexity는 O(1)이다. 새 노드를 삽입하거나 삭제하는데 걸리는 시간은 O(logN)이다. 이는 Heap 성질을 계속 유지시키기 위해 최악의 경우 트리 높이 만큼 비교 연산을 해야하기 때문이다(heapify).

*heapify* ?


cf. Binary Search Tree는 중복을 허용하지 않으나, Heap에서는 중복을 허용한다.

### Heap Sort
N개의 요소를 정렬할 경우 O(NlogN)이 소요된다. 정렬해야 할 N개의 요소들을 최대 힙으로 초기화한다. 그 다음, 하나씩 요소를 힙에서 꺼내 배열의 뒤부터 저장한다. 하나의 요소를 Heap에 삽입하거나 삭제할 때 Heap을 재정비하는 시간이 logN만큼 소요되고, 전체 요소 개수가 N개이므로 O(NlogN)이 걸린다. 힙 정렬은 전체 자료를 정렬하는 것이 아니라 가장 큰(작은) 값 몇 개만 필요할 때 유용하다.

## References 
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure 

http://cs.lmu.edu/~ray/classes/dsa/ 

C언어로 쉽게 풀어쓴 자료구조