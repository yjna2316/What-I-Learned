## Part1-4 Network
* [OSI 7계층](#OSI-7계층) 
* [HTTP VS HTTPS](#http-vs-https)
  * SSL / TLS
* [GET vs Post](#get-vs-post)
* [웹캐싱](#웹캐싱)
* [Cookie vs Session](#cookie-vs-session)
* [TCP/IP](#TCP/IP)
  * TCP와 UDP
  * 3 Way Handshaking
* [웹페이지가 표시되기까지 과정](#웹페이지가-표시되기까지-과정)
  * DNS 질의 과정(DNS query)
* [동기식 vs 비동기식 통신](#동기식-vs-비동기식-통신)
* [빅 엔디안 vs 리틀 엔디안](#빅-엔디안-vs-리틀-엔디안)
* [대칭키 암호화와 공개키 암호화](#대칭키-암호화와-공개키-암호화)
  * 전자인증서
  * 전자서명
-----------------------------------------
## OSI 7계층
OSI 모델은 **네트워크 통신 과정**을 7개의 독립적인 계층으로 구분한 것을 말한다. 기계에 가까울수록 하위계층이라 보면 된다. 프로그래밍 언어에서 저급언어는 컴퓨터가 읽기 쉬운 언어이고, 고급언어는 사람이 읽기 쉬운 언어인 것 처럼 OSI 7계층도 마찬가지라 생각하면 된다.
#### 1계층 - 물리 계층(Physical Layer)
* 역할: **데이터를 전기적인 신호로 변경하여 전송**
* 전송될 때 사용되는 모든 **물리적인 매개체** 해당
* 데이터 형태: 전기적 신호(0,1 - bit)
* 프로토콜: 없음
* 장비: 허브, 리피터
#### 2계층 - 데이터 링크 계층(Data Link Layer)
* 역할: **Mac주소** 통해 물리적인 장비 식별 및 물리계층의 물리적 전송 오류 해결(데이터 변조 여부 확인, 에러체크) 
* 데이터형태: Frame
* 프로토콜: 이더넷, 토큰링
* 장비: 브릿지, 스위치
#### 3계층 - 네트워크 계층(Network Layer)
* 역할: 데이터 전송경로 설정(**라우팅 기능**) -> **IP 주소**(호스트 구분하는 가상 주소)로 패킷 전달 
* 데이터 형태: Packet
* 프로토콜: IP, ARP, ICMP
* 장비: 라우터, L3 스위치
#### 4계층 - 트랜스포트 계층(Transport Layer)
* 역할: 데이터를 **프로세스(목적지)**에 전달, **오류관리 및 흐름제어와 데이터분할** 기능 제공
* Sender쪽에서는 데이터를 패킷단위로 분할하여 전송하고, Receiver측에서는 분할된 패킷을 재조립
* 방화벽과 프록시 서버가 이 계층에서 동작
* 데이터 형태: Segment
* 프로토콜: TCP, UDP
* 장비: L4 스위치
#### 5계층 - 세션 계층(Session Layer)
* 역할: **통신 장비간의 연결을 유지**하고 관리, 종료
* 프로토콜: NetBIOS, SAP, NWLink
* 장비: 컴퓨터
#### 6계층 - 표현 계층(Presentation Layer)
* 역할: 응용계층의 데이터를 범용적인 데이터 형식으로 변환, 압축, 암복호화 기능 제공
* 프로토콜: ASCII, MPEG, JPEG, MIDI
* 장비: 컴퓨터
#### 7계층 - 응용 계층(Application Layer)
* 역할: 사용자에게 **서비스 제공**
* 프로토콜: HTTP, SMTP, FTP, Telnet
* 장비: 컴퓨터

**프로토콜이란?**
컴퓨터 상호간의 대화에 필요한 통신 규약

---------------------------------------------------

## HTTP vs HTTPS 
### HTTP(Hyper Text Transfer Protocol)
* 웹에서 클라이언트와 서버 사이에 데이터를 주고 받을 때 사용하는 프로토콜 
* Connectionless하고 Stateless한 프로토콜(특징)
  * Connectionless: 클라이언트가 서버에 요청한 후 서버가 클라이언트에게 응답을 보내면 접속을 끊는다. -> HTTP1.1 버전 keep-alive (일정시간 지나면 closed) 
  * Stateless : 통신이 끝나면 상태 정보를 유지하지 않는다 -> 쿠키, 세션이용

**HTTP 메시지:**
통신 과정에서 주고받는 메시지 내용
* 요청
  * 요청 정보: 전송 방식(GET/POST), URL, HTTP 버전
  * 헤더: Host(웹 서버 정보), 웹브라우저 정보
  * (body): 생략가능, 사용자 요청 내용(POST 방식 사용시 / GET은 x)
* 응답
  * 응답 정보: HTTP 버전, 상태코드
  * 헤더: 메시지 상세 정보(파일 갱신 날짜, 크기)
  * 빈줄: 공란
  * body: 요청한 내용(HTML)

**HTTP 버전**
* HTTP 1.x: 여러개의 TCP 연결로 다수의 요청을 병렬로 처리함 (최대 6개 - 안정점) -> 완전한 멀티플렉싱 x
* HTTP 2.0: 하나의 TCP 연결로 다수의 요청과 응답을 동시에 처리함 -> 완전한 멀티플렉싱 
  * 바이너리 프레이밍 계층 (바이너리 형식의 더 작은 메시지와 프레임) 덕에 가능해짐(?)

* HTTP 보안 방법
  * (SSL과 조합하여) 통신 자체를 암호화: HTTPS 사용
  * HTTP 메시지 내용만 암호화

### HTTPS (HTTP over Secure socket layer)
 HTTP 통신하는 **소켓 부분을 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security) 프로토콜로 대체한 것으로, HTTP에 암호화와 인증, 데이터 무결성을 보장해준다**. HTTP는 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 **SSL이 TCP와 통신**하게 된다. 

* SSL / TLS 암호화 방식
  * 서버 인증서를 사용해 서버와 클라이언트 간 통신 구간을 암호화하는 방식 -> 암호화와 인증, 데이터 무결성 보장
  * 순서: 신원확인(인증서 발급) -> 암호화 통신
    * 인증서를 발급해 서버와 클라이언트를 인증(통신대상 인증), 데이터 위변조 방지 (인증서내 전자서명)
    * 암호화 통신: 대칭키와 공개키 암호화 방식을 혼합해 사용 
      * 공개키 암호화로 공유키 교환 후 공유키로 대칭키 암호화 통신
  * 조합 이유: 공개키 방식으로 암복호화 하는 것보다 공유키가 연산처리면에서 더 좋기 때문

#### HTTP vs HTTPS
* **HTTP는 평문 통신, HTTPS는	SSL을 사용한 암호화 통신**
  * HTTPS는 통신구간을 암호화하고 상대방 인증 및 데이터 무결성까지 보장해준다.
* 통신 순서가 다르다 
  *	HTTP 통신 순서: **TCP -> HTTP**
  *	HTTPS 통신 순서: **TCP -> SSL** ->HTTP
* 모든 사이트가 HTTPS를 사용하지 않는 이유는 속도 저하 때문: 암호화 통신은 CPU나 메모리 등 리소스가 많이 필요
  * 통신할 때마다 암호화하면 많은 리소스 소비하기 때문에 서버 한 대당 처리할 수 있는 요청 수가 줄어든다.
* 하지만, HTTP 2.0이 발전되면서 HTTPS가 HTTP보다 빠르다는 사실이 나왔다.
-------------
## GET vs POST
**HTTP프로토콜을 이용**해서 Client가 **Server에게** 데이터를 **요청**할 때 사용하는 방식이다. 
* GET 방식
  * 요청하는 데이터가 HTTP 메시지 **Header의 URL**? 뒤에 붙여서 전달된다
  * URL이라는 공간에 담겨가기 때문에 전송할 수 있는 **데이터 크기가 제한**되며
  *  데이터가 **그대로 노출**되므로 보안이 필요한 데이터에 대해서는 적절하지 않다. -> 인코딩 필요 (한글, 특수문자) 
  * 인코딩: 정보의 형태나 형식을 변환하는 처리 방식. 내용에는 변화가 없고 암호화로는 사용 불가능. 종류로 ASCII 등이 있다.
* POST 방식
  * 요청하는 데이터가 HTTP 메시지의 **Body** 부분에 넣어 전달된다 
  * 때문에 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.(하지만, 암호화를 하지 않는 이상 **둘다 보안에 취약**하다)
* 용도 
  * GET: 서버에서 **데이터를 조회할 때** 사용 (SQL의 SELECT문)
  * POST: 서버의 값이나 상태 **변경**시 사용
  * 차이: **GET 요청만 브라우저에 캐싱가능. 때문에 페이지 로드 시간을 줄일 수 있어 데이터 조회는 GET 사용.** 하지만 POST 요청할 것을(값 변경) GET방식을 사용하면 캐싱된 것을 가져와 원본이 아닌 복사본 변경만 발생가능

* 보안의 취약성 보완
  * HTTPS 사용(통신 구간 자체를 암호화)
  * 메시지 내용만 암호화
---------------
## 웹캐싱(클라이언트의 브라우저/ 프록시/ Gateway) 
웹캐시(프록시 서버)는 웹서버를 대신하여 HTTP 요구를 충족시켜주며, 최근 호출된 객체의 사본을 저장한다.
* 장점: 클라이언트 요청 응답시간 단축, 웹 트래픽 감소 
* 단점: 캐시된 이후에 웹 서버에 있는 원본 내용이 갱신되어 데이터 일관성 문제 

* CDN(Content Distribution Network)
  * 분산된 캐시
  * 사람들이 많이 찾을 것 같은 애들을 분산해 놓음. 요청오면 바로 보내줌. 
  * youtube 스트리밍 서비스, 게임 패치

Client가 요청하는 것(html, image, js, css)에 대해 처음 요청할 때는 서버에서 파일을 내려받고, 그 복사본을 특정 위치에  저장한다. 이후 동일한 URL 리소스 요청시, 서버가 아닌 내부에 저장된 파일을 사용하여 더 빠르게 서비스를 받는다. 그 결과 서버 다운 양, 응답시간, 네트워크 트래픽이 감소하는 효과를 볼 수 있다.

정리: 처음 요청시 -> 웹서버 접근 후 가까운 곳에 복사본 저장 -> 동일한 리소스 재요청시 웹서버 접근 없이 캐시에서 바로 가져옴

------------------------------------------------------------------------------------------
## Cookie vs Session
HTTP는 stateless하기 때문에(상태 정보를 저장하지 않기 때문에) 사용자 정보를 유지하기 위해 쿠키와 세션을 이용한다.
* 쿠키(Cookie) 
  * **클라이언트에 저장되는 키와 값으로 구성된 작은 데이터 파일** (4KB, 일정시간 지나면 삭제됨)
  * 일정시간 동안 데이터를 저장할 수 있어 로그인 상태나 사용자 정보 유지에 사용한다. 
  * 보안이 취약하고 조작이 가능 (단점)
  * 클라이언트 상에 동작하기 때문에 서버 부하가 낮고, 속도가 빠름(장점)
  * 사용 예 
    * 자동 로그인
    * 팝업의 오늘 이 창을 다시 보지 않음 체크
    * 방문한 웹페이지에 기초하여 제품 추천
    * 장바구니
  * 과정
    * 처음 접속하는 경우 서버가 요청에 대한 응답에 쿠키를 함께 보냄 (응답 헤더의 Set-Cookie 속성 사용)
    * 쿠키가 클라이언트에 저장됨
    * 다음 요청부터 메시지 보낼 때 쿠키를 함께 보냄 (요청 헤더)
    * 서버가 쿠키를 보고 사용자를 식별하고, 로그인 정보도 유지하게 됨
  * 보안
    * 중요한 정보는 PC의 쿠키가 아닌 서버 쪽에 저장한다. 
    * 이 때, 동일한 사용자인지 확인하기 위해 세션ID 식별 정보만 클라이언트에 쿠키로 저장한다. 


* 세션
  * **일정 시간동안 같은 브라우저로부터** 들어오는 일련의 요구를 하나의 상태로 보고 그 **상태를 유지하는 기술** 
  * 세션ID(식별정보)를 쿠키에 저장해 클라이언트 구분
  * 사용자 정보를 서버에 저장하기 때문에 사용자 정보가 노출되진 않지만(장점)
  * 서버의 자원을 사용하고 서버에서 처리하기 때문에 속도가 느리고 서버 부하가 커짐(단점)
  * 사용 예
    * 로그인 정보 유지

* 쿠키 vs 세션
  * **저장위치** 
    * 쿠키는 클라이언트에 파일로 저장
    * 세션은 서버에 저장
  * **보안** 
    * 쿠키는 내용이 변조되거나 요청 과정에서 스나이핑 당할 수 있어 보안에 취약하지만
    * 세션은 쿠키를 이용해 세션ID만(식별정보) 저장하고 나머지는 서버에서 처리하기 때문에 비교적 보안성 좋다
  * **라이플 사이클**
    * 쿠키는 파일로 저장되기 때문에 브라우저 종료 상관 없이 **만료기간**이 끝날 때까지 살아있다. 
    * 세션은 만료기간 상관 없이 **브라우저가** 종료되면 삭제된다.
  * **속도**
    * 쿠키는 로컬에 정보가 있기 때문에 속도가 빠르지만
    * 세션은 정보가 서버에 있기 때문에 서버에서의 처리가 요구되어 요청 응답 속도가 느림

* 캐시는 이미지나 CSS, JS파일등이 사용자 브라우저에 저장되는 것. 필요한 자원을 가져오는 시간 단축하기 위함. 
* 쿠키와 세션은 상태 정보를 유지하기 위함 

-------------------------------------------------------------------------------------------
## TCP/IP
* 인터넷(이 사용하는) 표준 프로토콜로 IP 프로토콜 위에 TCP 프로토콜을 조합한 것을 말한다. 
* 인터넷 경로 제어와 함께 종단 간 신뢰성이 높은 통신을 가능케 해준다.
* 총 4계층으로 구성: 네트워크 접속 계층(=물리/데이터링크 계층) -> 네트워크 -> 전송 -> 응용 

#### TCP(Transmission Control Protocol)
* 연결형 프로토콜
  * 연결시 3-way-handshaking, 세션 종료시 4-way-handshaking
* 속도보다 정확도 중시 
  * 패킷 순차적 전달, 손실 발생시 재전송
  * 상위층이 넘겨준 데이터를 세그먼트 단위로 쪼개어 순서를 부여하여 전송 및 수신하여 순서가 뒤바뀌는 일이 없도록 한다.
  * 흐름 / 혼잡제어 / 오류검출 
* 바이트 스트림 전송
  
#### UDP(User Datagram Protocol)
* **비연결형** 프로토콜
* 데이터의 정확한 전달보다 **속도를 중시**
  * 오류 검출시 재전송x 해당 패킷을 버림
* 실시간 전송에 유리 - 온라인 게임, 스트리밍 서비스
  * TCP에서는 스트리밍 비디오의 점 하나의 데이터를 받지 못하면 버퍼링이 발생할 수 있지만, UDP의 경우 이를 무시하고 계속 플레이될 것이다.
* 데이터그램 전송
* DNS, RIP(라우팅프로토콜, 최단 경로 결정)
* 소량 데이터 전송시 사용

| TCP | UDP |
|:------------------------------------:|:-----------------------------:|
| 연결지향(TCP 3 Way Handshake 사용) | 비연결 |
| 정확한 전달 중시(순차적 전달, 재전송 / 웹, 이메일) | 빠른 전달 중시 (실시간 전송, 게임, 스트리밍 서비스) |
| **HTTP**, HTTPS, FTP, SMTP | **DNS**, RIP, SNMP, TFTP|
| 정확한 목적지 전달 보장 | 보장 x |
| 흐름/혼잡제어/에러 체크(완전한 수신 가능) | 없음 |
| 대량 데이터 | 소량 데이터|
| 1대1, 양방향 통신 | 1대1, 1대다, 다대다 통신|
| 바이트 스트림 전송(세그먼트 단위) | Datagram |

* 공통점 
  * 인터넷에서 패킷 전송에 사용되는 프로토콜 
  * IP 프로토콜을 기반으로 TCP / UDP 상관없이 모든 해당 패킷은 IP주소로 전송됨.

* 혼잡 제어: 네트워크내 패킷수 과도하게 증가 방지 (ex) 라우터 오버플로우로 인한 데이터 손실)
  * SlowStart - 1개씩 시작
* 흐름 제어: 수신측 상태에 따라 전송량 조절 
  * Stop & Wait: 확인응답 받은 후에 다음 패킷 전송
  * Sliding Window: 확인응답 없
  어도 수신측 윈도우 크기만큼 전송


### TCP 연결(3 Way Handshaking) (그림 그려보기)
* 두 종단간 TCP 연결 과정(3단계)
* 연결 후 종단간 데이터 전송 가능, 전송이 끝나면 연결 끊김
* 연결하는 동안 원활한 통신을 위해 초기 순차 일련번호와 최대 세그먼트 크기 상호 협의

---------------------------------------------------------------
## 웹페이지가 표시되기까지 과정

**요약: 브라우저에 도메인 입력 -> DNS 서버에 IP 주소 요청 -> 수신한 IP 주소에 해당하는 웹서버에 접속 -> 페이지 정보 수신(HTML 형식)**

#### 1. 로컬 PC의 호스트 파일 먼저 검색
host 파일: 초창기 인터넷에서 도메인 네임과 IP주소를 대응시켜 저장한 텍스트 파일. 
DNS 등록 전 서버나, 등록할 수 없는 서버 접근시 주로 사용하며, 
사용자 입력을 통한 업데이트가 필요하다.\
host파일에 해당 도메인이 있으면 질의없이 바로 접속, 없으면 DNS 서버에 질의 

#### 2. DHCP & ARP 통한 외부와의 통신 준비
사용자 PC는 DHCP서버에게 
* 사용자 자신의 IP주소
* 가장 가까운 라우터 IP주소
* 가까운 DNS서버 IP주소

를 받는다. 이후 ARP 프로토콜을 이용해 IP주소 기반으로 가장 가까운 라우터의 MAC주소를 알아낸다.

**ARP:** IP주소를 MAC주소로 변환하는 프로토콜

**DHCP:** LAN내 컴퓨터에게 IP 자동 할당 프로토콜(네임서버, 게이트웨이, 자신의 IP주소)
* 일정기간동안 임대해주고 회수하는 동적 프로토콜 (유동 IP 주소)
  * 컴퓨터 수가 증가하고 PC 자체의 변경사항이 많아졌을 때, IP 충돌을 방지하고 자동으로 관리하기 위함

* IP주소 할당 방법(broadcast)
  * 새로운 pc가 들어옴(IP주소가 없는 상태) 
  * 자신의 IP주소를 할당받기 위해 브로드캐스트로 LAN내 모든 애들에게 DHCP 메시지를 뿌림 -> DHCP 서버의 IP주소를 모르니까
  * 메시지를 받은 DHCP 서버는 사용가능한 IP 주소 자동할당하여 브로드캐스트 -> 신규 호스트는 아직 IP 주소가 없으니까
  * 메시지를 받은 다른 호스트들은 해당 패킷이 자신과 관계가 없으므로 버림

* 고정 IP 주소: ISP(인터넷 서비스 제공자)에 의해 사용자 전용으로 부여되는 고유 인터넷 주소를 말한다. 인터넷 상에 데이터를 주고받거나 특정 컴퓨터를 찾을 때 사용된다. (예.DNS 서버) 하지만, IP 주소 부족 문제로 DHCP 서버를 이용해 필요할때마다 '임시' IP주소를 할당받고 회수하는 유동 IP주소를 사용한다. (일정시간이 지나면 접속 끊김)

#### 3. DNS쿼리 통해 웹 서버 IP주소 수신 
* **DNS**(Domain Name System): (사람이 기억하기 쉬운)도메인과 IP주소를 변환해주는 서비스 / UDP 사용

**DNS 서버 질의 과정(DNS query)**
1. 브라우저에 도메인 이름을 입력하면 (www.google.com)
2. 해당 도메인의 IP주소를 PC에서 로컬 DNS 서버에 질의한다.
3. 로컬 DNS는 캐시를 먼저 확인하고 없으면 루트 DNS에 질의를 하고 답을 받는다. (.com의 IP 주소) 
4. 로컬 DNS는 .com 네임서버에 다시 질의하고 google.com의 IP주소를 받는다.
5. 로컬 DNS는 google.com의 네임서버에 다시 질의하고 해당 도메인의 IP주소 (예)204.71.200.74를 받는다.

* 캐시 이용: DNS서버는 한번 검색한 결과를 메모리 캐시에 저장한다. 따라서, 같은 정보를 요청받으면 root 네임 서버에 질의 않고 캐시 정보를 전송한다. 캐시 정보는 유효기간(TTL: Time to Live)이 지나면 자동 삭제된다.

#### 4. 웹 서버 접속
* HTTP 요청 위해 TCP연결 (3-way-handshaking)
* TCP 소켓으로 HTTP Request 보냄
* 웹 정보가 사용자 PC로 수신됨(HTML 형식, 화면 구성에 필요한 정보)

* TCP 작동 방식
브라우저에서 웹 페이지 요청시, TCP 패킷을 웹 서버로 전송해 정보를 요청한다.
웹서버는 웹 페이지를 보여주기 위해 웹 브라우저에 TCP 패킷 스트림을 보내 응답함.
TCP는 전송된 패킷 추적하여 전송 중 데이터가 손실/손상되었는지 확인
TCP는 먼저 번호를 매겨 패킷을 주문, 두번째로 수신자가 메시지 받았음을 알리는 응답 보내도록 하여 오류 검사 수행 - 필요시 재전송

-------------------------------------------------------------------------------------

## 동기식 vs 비동기식 통신
서버와 통신 방법. 패킷 단위의 데이터 길이가 일정하냐 일정하지 않느냐의 차이점이 있다.
* 동기식 전송 
  * **미리 정해진 수만큼의 문자열**을 한 블록으로 만들어 일시에 전송하는 방식
  * 송신측과 수신측이 **하나의 기준 클록으로 동기신호를 맞추어 동작**
  * **원거리** 전송에 사용, 전송속도가 **빠름**
  * 시작/종료 비트로 인한 오버헤드가 없고, 휴지 시간이 없으므로 전송 효율이 좋다. 
* 비동기식 전송
  * 송/수신간의 별도의 동기없이 데이터를 주고 받는 방식  
  * **한번에 한 문자씩** 전송
  * **단거리** 전송에 사용, 전송속도가 **느림**
  * 문자마다 시작, 정지를 알리는 비트가 추가되므로 전송 효율이 떨어진다. 
--------------------------------------
## 빅 엔디안 vs 리틀 엔디안
CPU에 따라 데이터를 메모리에 저장하는 방식이 달라진다. 이러한 부분을 고려하지 않고 데이터를 송수신하면, 데이터 해석 순서가 달라져 문제가 발생할 수 있다.

CPU가 **데이터를 메모리에 저장하는 방식**(또는 데이터를 해석하는 방식, **바이트 순서**)은 두가지로 나뉜다.
* **빅 엔디안(Big Endian)**: 상위 바이트 값을 작은 번지수에 저장
* **리틀 엔디안(Little Endian)**: 상위 바이트 값을 큰 번지수에 저장

저장 방식이 서로 다른 CPU끼리 데이터를 송수신 한다면 그 과정에서 문제가 생길 것이므로, 이 문제를 해결하기 위해 통일된 기준으로 네트워크를 사용하게 된다. 이것을 **네트워크 바이트 순서(빅 엔디안 방식)**이라 한다.

-----------------------------------------------------------------------
## 대칭키 암호화와 공개키 암호화
### 대칭키 암호화 방식
* **하나의 키로 암복호화**
* 공개키 암호화 보다 빠르고, 처리방식이 간단하다(장점)
* 상대방과 같은키를 공유해야 하는데, 전달과정에서 해킹이 가능하다(단점)

### 공개키 암호화 방식
* **암호화 키와 복호화 키를 따로 만들어 한 세트로 관리(공개키, 개인키)**
* 상대에게 자신의 공개키를 미리 전달 (나 -> 상대, 공개키 전달)
* 상대는 공개키로 암호화해 전달 (상대 -> 나, 공개키로 암호화)
* 개인키로 복호화 (나, 개인키로 복호화)
* 상대가 누구인지 인증 못함(단점) 
  * 공개키를 중간에 가로채서 신분 사칭하고 이상한 내용을 보낼 수 있음

### 전자인증서
* 본인임을 증명할 수 있음(공개키 + 전자서명) 
* 신분 사칭 & 데이터 위변조 방지(전자서명)

### 전자서명(?)
* 데이터 내용이 **위변조되지 않았음**과 **누가 보냈는지**를 보증해준다
* 위변조 여부는 해시값 이용 -> 원본과 같다면 해시값이 같다. 암호화된 원본 데이터와 해시값을 함께 전송

-----------------------------------------------------------------------
### References
* 인코딩\
http://itstory.tk/entry/%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80-ASCII-URL-HTML-Base64-MS-Script-%EC%9D%B8%EC%BD%94%EB%94%A9
* TCP vs UDP\
http://slic.tistory.com/1401 
* 쿠키와 세션\
http://jeong-pro.tistory.com/80
* 소켓프로그래밍, 바이트순서\
https://www.slideshare.net/ssusereb4897/ss-40765344 
* 동기, 비동기\
http://jajubogi.tistory.com/14
* https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network 
* 리브로웍스, 명쾌한 설명과 풍부한 그림으로 배우는 TCP/IP 쉽게, 더쉽게