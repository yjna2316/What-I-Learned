## Part1-4 Network
* OSI 7계층 
* HTTP VS HTTPS
  * GET, POST 방식 비교
  * SSL vs TLS
* 쿠키 vs 세션
* TCP/IP
  * TCP와 UDP
  * 3 Way Handshaking
* 동기식 통신 vs 비동기식 통신
* 웹페이지가 표시되기까지 과정
  * DNS 질의 과정(DNS query)
* 대칭키 암호화와 공개키 암호화
-----------------------------------------
## OSI 7계층
OSI 모델은 **네트워크 통신 과정**을 7개의 독립적인 계층으로 구분한 것을 말한다. 기계에 가까울수록 하위계층이라 보면 된다. 이는 프로그래밍 언어에서 저급언어는 컴퓨터가 읽기 쉬운 언어이고, 고급언어는 사람이 읽기 쉬운 언어인것 처럼 OSI 7계층도 마찬가지라 생각하면 된다.
#### 1계층 - 물리 계층(Physical Layer)
* 데이터를 전기적인 신호로 변경하여 실질적인 전송을 담당하는 계층
* 데이터가 전송될 때 사용되는 모든 물리적인 매개체 해당
* 데이터 형태: 전기적 신호(0,1 - bit)
* 프로토콜: 없음
* 장비: 허브, 리피터
#### 2계층 - 데이터 링크 계층(Data Link Layer)
#### 3계층 - 네트워크 계층(Network Layer)
#### 4계층 - 트랜스포트 계층(Transport Layer)
* 두 종단간에 신뢰성있는 데이터 전송 보장
* 오류복구, 흐름제어 담당
* Sender쪽에서는 데이터를 패킷단위로 분할하여 전송하고, Receiver측에서는 분할된 패킷을 재조립
* 연결형 프로토콜과 비연결형 프로토콜 제공(TCP, UDP)
* 방화벽과 프록시 서버가 이 계층에서 동작
#### 5계층 - 세션 계층(Session Layer)
#### 6계층 - 표현 계층(Presentation Layer)
#### 7계층 - 응용 계층(Application Layer)


---------------------------------------------------

## HTTP vs HTTPS
### HTTP(Hyper Text Transfer Protocol)
**웹에서** 클라이언트와 서버 사이에 **데이터를 주고 받을 때 사용하는 프로토콜**

**HTTP 메시지:**
통신 과정에서 주고받는 메시지 내용
* 요청
  * 요청 정보: 전송 방식(GET/POST), URL, HTTP 버전
  * 헤더: Host(웹 서버 정보), 웹브라우저 정보
  * (body): 생략가능, 사용자 요청 내용(POST 방식 사용시 / GET은 x)
* 응답
  * 응답 정보: HTTP 버전, 상태코드
  * 헤더: 메시지 상세 정보(파일 갱신 날짜, 크기)
  * 빈줄: 공란
  * body: 요청한 내용(HTML)

**HTTP 버전**
* HTTP 1.x: 여러개의 TCP 연결로 다수의 요청을 병렬로 처리함 (최대 6개 - 안정점) -> 완전한 멀티플렉싱 x
* HTTP 2.0: 하나의 TCP 연결로 다수의 요청과 응답을 동시에 처리함 -> 완전한 멀티플렉싱 
  * 바이너리 프레이밍 계층 (바이너리 형식의 더 작은 메시지와 프레임) 덕에 가능해짐(?)

### HTTPS (HTTP over Secure socket layer) (???)
HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니다. HTTP 통신하는 **소켓 부분을 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security) 프로토콜로 대체한 것으로, 기존의 HTTP 기능에 암호화, 인증, 데이터 무결성을 보장해준다**. HTTP는 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 **SSL이 TCP와 통신**하게 된다. 

#### HTTP vs HTTPS(????)
-	HTTP 동작순서: TCP -> HTTP
-	HTTPS 동작순서: TCP -> SSL ->HTTP
-	SSL을 사용하는 것이 차이점이다. 정보 암호화시 공개키와 개인키라는 두가지 키를 이용하는 방법이다. (정보를 암호화하는 프로토콜을 이용하여 데이터를 전송하고 있다는 것을 의미)
-	문서 전송시, 암호화 처리를 하냐 안하냐의 차이이다. 모든 사이트가 HTTPS를 사용하지 않는 이유는 속도 저하 때문이다.
- 하지만, HTTP 2.0이 발전되면서 HTTPS가 HTTP보다 빠르다는 사실이 나왔다.

### GET vs POST
**HTTP프로토콜을 이용**해서 Client가 **Server에게** 데이터를 **요청**할 때 사용하는 방식이다. 
* GET 방식
  * 요청하는 데이터가 HTTP 메시지 **Header의 URL**? 뒤에 붙여서 전달된다
  * URL이라는 공간에 담겨가기 때문에 전송할 수 있는 **데이터 크기가 제한**되며
  *  데이터가 **그대로 노출**되므로 보안이 필요한 데이터에 대해서는 적절하지 않다. -> 인코딩 필요 (한글, 특수문자) 
  * 인코딩: 정보의 형태나 형식을 변환하는 처리 방식. 내용에는 변화가 없고 암호화로는 사용 불가능. 종류로 ASCII 등이 있다.
* POST 방식
  * 요청하는 데이터가 HTTP 메시지의 **Body** 부분에 넣어 전달된다 
  * 때문에 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.(하지만, 암호화를 하지 않는 이상 **둘다 보안에 취약**하다)
* 용도 
  * GET: 서버에서 **데이터를 조회할 때** 사용 (SQL의 SELECT문)
  * POST: 서버의 값이나 상태 **변경**시 사용
  * 차이: GET은 브라우저에 캐싱가능 / POST는 불가 ??
* 보안의 취약성 보완
  * HTTPS 사용(통신 구간 자체를 암호화)
  * 메시지 내용만 암호화

#### 웹캐시(클라이언트의 브라우저/ 프록시/ Gateway) 
Client가 요청하는 것(html, image, js, css)에 대해 처음 요청할 때는 서버에서 파일을 내려받고, 그 복사본을 특정 위치에  저장한다. 이후 동일한 URL 리소스 요청시, 서버가 아닌 내부에 저장된 파일을 사용하여 더 빠르게 서비스를 받는다. 그 결과 서버 다운 양, 응답시간, 네트워크 트래픽이 감소하는 효과를 볼 수 있다.

정리: 처음 요청시 -> 웹서버 접근 후 가까운 곳에 복사본 저장 -> 동일한 리소스 재요청시 웹서버 접근 없이 캐시에서 바로 가져옴

------------------------------------------------------------------------------------------
## Cookie vs Session
HTTP는 상태정보를 저장하지 않기 때문에 (그래서 어떤 문제 발생??)이를 보완하기 위해 쿠키와 세션을 사용한다.

-------------------------------------------------------------------------------------------
## TCP/IP
* 인터넷(이 사용하는) 표준 프로토콜로 IP 프로토콜 위에 TCP 프로토콜을 조합한 것을 말한다. 
* 인터넷 경로 제어와 함께 종단 간 신뢰성이 높은 통신을 가능케 해준다.
* 총 4계층으로 구성: 네트워크 접속 계층(=물리/데이터링크 계층) -> 네트워크 -> 전송 -> 응용 
### TCP VS UDP
전송계층의 프로토콜
* 공통점: 인터넷에서 패킷 전송에 사용되는 프로토콜. IP 프로토콜을 기반으로 TCP/UDP 상관없이 모든 해당 패킷은 IP주소로 전송됨.

#### TCP(Transmission Control Protocol)
* 연결형 프로토콜
  * 연결시 3-way-handshaking, 세션 종료시 4-way-handshaking
* 속도보다 정확도 중시 
  * 패킷 순차적 전달, 손실 발생시 재전송
  * 상위층이 넘겨준 데이터를 세그먼트 단위로 쪼개어 순서를 부여하여 전송 및 수신하여 순서가 뒤바뀌는 일이 없도록 한다.
  * 흐름 / 혼잡제어 / 오류검출 
* 바이트 스트림 전송
  

#### UDP(User Datagram Protocol)
* **비연결형** 프로토콜
* 데이터의 정확한 전달보다 **속도를 중시**
  * 오류 검출시 재전송x 해당 패킷을 버림
* 실시간 전송에 유리 - 온라인 게임, 스트리밍 서비스
  * TCP에서는 스트리밍 비디오의 점 하나의 데이터를 받지 못하면 버퍼링이 발생할 수 있지만, UDP의 경우 이를 무시하고 계속 플레이될 것이다.
* 데이터그램 전송
* DNS, RIP(라우팅프로토콜, 최단 경로 결정)
* 소량 데이터 전송시 사용

| TCP | UDP |
|:------------------------------------:|:-----------------------------:|
| 연결지향(TCP 3 Way Handshake 사용) | 비연결 |
| 정확한 전달 중시(순차적 전달, 재전송) | 빠른 전달 중시 (실시간 전송, 게임, 스트리밍 서비스) |
| **HTTP**, HTTPS, FTP, SMTP | **DNS**, RIP, SNMP, TFTP|
| 정확한 목적지 전달 보장 | 보장 x |
| 흐름/혼잡제어/에러 체크(완전한 수신 가능) | 없음 |
| 대량 데이터 | 소량 데이터|
| 1대1, 양방향 통신 | 1대1, 1대다, 다대다 통신|
| 바이트 스트림 전송(세그먼트 단위) | Datagram |
|||

* 혼잡 제어: 네트워크내 패킷수 과도하게 증가 방지 (ex) 라우터 오버플로우로 인한 데이터 손실)
  * SlowStart - 1개씩 시작
* 흐름 제어: 수신측 상태에 따라 전송량 조절 
  * Stop & Wait: 확인응답 받은 후에 다음 패킷 전송
  * Sliding Window: 확인응답 없
  어도 수신측 윈도우 크기만큼 전송


### TCP 연결(3 Way Handshaking) (그림 그려보기)
* 두 종단간 TCP 연결 과정(3단계)
* 연결 후 종단간 데이터 전송 가능, 전송이 끝나면 연결 끊김
* 연결하는 동안 원활한 통신을 위해 초기 순차 일련번호와 최대 세그먼트 크기 상호 협의
-------------------------------------------------------------------------------------

## 비동기식 vs 동기식 통신
서버와 통신 방법 중 동기식과 비동기식 통신이 있다. 패킷 단위의 데이터 길이가 일정하냐 일정하지 않느냐의 차이점이 있다.
* 동기식 전송 : 미리 정해진 수만큼의 문자열을 한 블록으로 만들어 일시에 전송하는 방식, 원거리 전송에 주로 사용, 전송속도가 빠르다. 시작/종료 비트로 인한 오버헤드가 없고, 휴지 시간이 없으므로 전송 효율이 좋다. 
* 비동기식 전송 : 송/수신간의 별도의 동기없이 데이터를 주고 받는 방식. 단거리 전송에 주로 사용. 전송속도가 느리다. 문자마다 시작, 정지를 알리는 비트가 추가되므로 전송 효율이 떨어진다. 

---------------------------------------------------------------
## 웹페이지가 표시되기까지 과정

**요약: 브라우저에 도메인 입력 -> DNS 서버에 IP 주소 요청 -> 수신한 IP 주소에 해당하는 웹서버에 접속 -> 페이지 정보 수신(HTML 형식)**

#### 1. 로컬 PC의 호스트 파일 먼저 검색
host 파일: 초창기 인터넷에서 도메인 네임과 IP주소를 대응시켜 저장한 텍스트 파일. 
DNS 등록 전 서버나, 등록할 수 없는 서버 접근시 주로 사용하며, 
사용자 입력을 통한 업데이트가 필요하다.\
host파일에 해당 도메인이 있으면 질의없이 바로 접속, 없으면 DNS 서버에 질의 

#### 2. DHCP & ARP 통한 외부와의 통신 준비
사용자 PC는 DHCP서버에게 
* 사용자 자신의 IP주소
* 가장 가까운 라우터 IP주소
* 가까운 DNS서버 IP주소

를 받는다. 이후 ARP 프로토콜을 이용해 IP주소 기반으로 가장 가까운 라우터의 MAC주소를 알아낸다.

**ARP:** IP주소를 MAC주소로 변환하는 프로토콜

**DHCP:** LAN내 컴퓨터에게 IP 자동 할당 프로토콜(네임서버, 게이트웨이, 자신의 IP주소)
* 일정기간동안 임대해주고 회수하는 동적 프로토콜 (유동 IP 주소)
  * 컴퓨터 수가 증가하고 PC 자체의 변경사항이 많아졌을 때, IP 충돌을 방지하고 자동으로 관리하기 위함

* IP주소 할당 방법(broadcast)
  * 새로운 pc가 들어옴(IP주소가 없는 상태) 
  * 자신의 IP주소를 할당받기 위해 브로드캐스트로 LAN내 모든 애들에게 DHCP 메시지를 뿌림 -> DHCP 서버의 IP주소를 모르니까
  * 메시지를 받은 DHCP 서버는 사용가능한 IP 주소 자동할당하여 브로드캐스트 -> 신규 호스트는 아직 IP 주소가 없으니까
  * 메시지를 받은 다른 호스트들은 해당 패킷이 자신과 관계가 없으므로 버림

* 고정 IP 주소: ISP(인터넷 서비스 제공자)에 의해 사용자 전용으로 부여되는 고유 인터넷 주소를 말한다. 인터넷 상에 데이터를 주고받거나 특정 컴퓨터를 찾을 때 사용된다. (예.DNS 서버) 하지만, IP 주소 부족 문제로 DHCP 서버를 이용해 필요할때마다 '임시' IP주소를 할당받고 회수하는 유동 IP주소를 사용한다. (일정시간이 지나면 접속 끊김)

#### 3. DNS쿼리 통해 웹 서버 IP주소 수신 
* **DNS**(Domain Name System): (사람이 기억하기 쉬운)도메인과 IP주소를 변환해주는 서비스 / UDP 사용

**DNS 서버 질의 과정(DNS query)**
1. 브라우저에 도메인 이름을 입력하면 (www.google.com)
2. 해당 도메인의 IP주소를 PC에서 로컬 DNS 서버에 질의한다.
3. 로컬 DNS는 캐시를 먼저 확인하고 없으면 루트 DNS에 질의를 하고 답을 받는다. (.com의 IP 주소) 
4. 로컬 DNS는 .com 네임서버에 다시 질의하고 google.com의 IP주소를 받는다.
5. 로컬 DNS는 google.com의 네임서버에 다시 질의하고 해당 도메인의 IP주소 (예)204.71.200.74를 받는다.

* 캐시 이용: DNS서버는 한번 검색한 결과를 메모리 캐시에 저장한다. 따라서, 같은 정보를 요청받으면 root 네임 서버에 질의 않고 캐시 정보를 전송한다. 캐시 정보는 유효기간(TTL: Time to Live)이 지나면 자동 삭제된다.

#### 4. 웹 서버 접속
* HTTP 요청 위해 TCP연결 (3-way-handshaking)
* TCP 소켓으로 HTTP Request 보냄
* 웹 정보가 사용자 PC로 수신됨(HTML 형식, 화면 구성에 필요한 정보)

* TCP 작동 방식
브라우저에서 웹 페이지 요청시, TCP 패킷을 웹 서버로 전송해 정보를 요청한다.
웹서버는 웹 페이지를 보여주기 위해 웹 브라우저에 TCP 패킷 스트림을 보내 응답함.
TCP는 전송된 패킷 추적하여 전송 중 데이터가 손실/손상되었는지 확인
TCP는 먼저 번호를 매겨 패킷을 주문, 두번째로 수신자가 메시지 받았음을 알리는 응답 보내도록 하여 오류 검사 수행 - 필요시 재전송

-----------------------------------------------------------------------
## 대칭키 암호화와 공개키 암호화
-----------------------------------------------------------------------
### References
* 인코딩: http://itstory.tk/entry/%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80-ASCII-URL-HTML-Base64-MS-Script-%EC%9D%B8%EC%BD%94%EB%94%A9
* TCP vs UDP: http://slic.tistory.com/1401 
* https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network 