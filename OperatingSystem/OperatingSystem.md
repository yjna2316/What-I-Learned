# Part1-3 Operating System
* [Process Management](#process-management)
  * Process
    * Process State
    * Process Control Block(PCB)
  * Context Switching
  * Process Scheduling Queue
  * Thread
* [CPU Sheduling](#cpu-scheduling)
  * CPU Schedular
  * Dispacher
  * Scheduling Algorithm
* [Memory Management](#Memory-Management)
  * Background
    * Program Execution 
    * Swapping
    * Fragmentation
    * Address Binding
  * Physical Memory Allocationg
  * Paging
  * Segmentation
  * Paged Segmentation
* [Virtual Memory](#virtual-memory)
  * Demand Paging
    * Page Fault
  * Page Replacement 
  * Page Frame Allocation
    * Global vs Local Replacement
  * Thrashing
* References

# Memory Management
## Background
### Pragram Execution
'프로그램이 실행되고 있다'는 다음과 같은 의미를 갖는다. 
1. 디스크에 존재하던 실행 파일이 Memory에 올라감
2. 프로그램이 CPU를 할당 받고 명령어를 수행하고 있는 상태

프로그램이 실행되기 전 컴파일된 실행 파일은 디스크(File System)에 존재한다. 프로그램이 실행되면 프로그램마다 독자적인 주소공간이 생성되고 주소변환(논리 주소 -> 실제 주소)에 의해 프로세스의 가상 주소 공간이 Physical Memory에 적재된다. 이때 실행 파일 전체가 Memory에 통째로 올라가기보단 당장 CPU 수행에 필요한 부분만 올라가게 되고 나머지는 디스크(Swap Area)에 내려가 있는다. 이는 여러 Process가 공유하는 Memory 공간을 효율적으로 사용하기 위해서이다. 

* Swap Area vs File System
Swap 영역은 Disk내 File System과 별도로 존재하는 영역으로, 메모리 연장 공간으로 사용된다. 프로세스가 수행중인 동안에만 Disk에 **일시적**으로 저장된다. 즉, 전원

### Swapping
메모리에 올라가 있는 프로세스 전체를 디스크의 Swap 영역으로 가져가는걸 말한다. 디스크에서 메모리로 옮기는 작업을 Swap In, 메모리에서 디스크로 옮기는 작업을 Swap Out이라 한다.

#### Physical Memory 영역
Physical Memory는 **운영체제 상주 영역**과 **사용자 프로세스 영역**으로 나뉘어 사용된다. OS 상주 영역은 인터럽트 벡터와 함께 메모리 낮은 주소 영역을 사용하며 OS 커널이 이곳에 위치한다. 사용자 영역은 메모리의 높은 주소를 사용하며 여러 프로세스들이 이곳에 적재되어 실행된다. 여기에서는 사용자 영역의 관리 방법에 대해 살펴볼 것이다.

### Fragmentation(단편화) 
프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못하는 빈 공간들이 늘어나게 되는데 이것이 단편화이다. 2가지 종류가 있다.
* 외부 조각: 프로그램 크기보다 분할의 크기가 작아 사용하지 못하는 메모리 공간
* 내부 조각: 프로세스가 사용하고 남은 메모리 공간. 이 공간은 특정 프로그램에게 이미 할당되었으므로 이 공간을 사용할 수 있는 작은 크기의 프로그램이 있다 해도 사용될 수가 없다. 공간 낭비 
ex) 지하철 좌석 

#### Compaction(압축)
외부 조각 문제를 해결하기 위해 프로세스가 사용중인 메모리 영역을 한쪽으로 몰아 사용할 수 있는 하나의 큰 공간을 만드는 방법이다. 이 방법은 현재 수행중인 프로세스의 메모리 위치를 상당 부분 이동시켜야 하므로 작업 효율이 좋지 못하다. 또한, 실행 도중에 프로세스 주소가 동적으로 바뀌어야 하므로 실행 시간 바인딩 방식이 지원되어야 한다.

## Physical Memory Allocation
### Contiguous Allocation
프로세스를 **통째로** 메모리에 올리는 방법으로 Memory를 미리 나눠놓느냐 아니냐에 따라 고정 분할 할당과 가변 분할 할당으로 나뉜다. Memory 크기보다 큰 프로세스는 못 올리는 단점이 있다.

#### Fixed Partition Allocation 
메모리를 고정된 크기(영구적)로 미리 나눠놓고 하나의 분할에 하나의 프로세스를 올리는 방식이다. 올릴 수 있는 프로그램 수가 고정되어 있고, 분할 크기보다 큰 프로세스는 못 올린다는 제약이 있다. 또한, 외부 조각과 내부 조각이 발생할 수 있다.

#### Variable Partition Allocation
메모리를 미리 나눠놓지 않고 프로그램 크기에 따라 메모리를 할당해 주는 방식으로 분할 크기와 개수가 달라진다. 외부 조각이 발생할 수 있다.

#### 동적 메모리 할당 문제
프로세스를 메모리에 올릴 때 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 것인지를 결정하는 문제로 가용 공간이란 사용되지 않은 메모리 공간을 말한다. 이 문제를 해결하는 방법으로 
* First Fit: 프로그램 크기보다 큰 것 중 최초로 찾아지는 공간에 할당. 속도 측면 효과적
* Best Fit: 프로그램 크기와 가장 비슷한 공간 찾아 할당. 공간 이용률 좋음
* Worst Fit: 가장 큰 공간에 할당. 

### Noncontiguous Allocation
하나의 프로세스를 여러개로 쪼개서 분산시켜 메모리에 올리는 방법. 프로그램을 동일한 크기로 나누어 메모리에 올리는 Paging, 의미 단위로 나누어 메모리에 올리는 Segmentation, 세그멘테이션 내에서 동일한 크기의 페이지를 나누어 메모리에 올리는 Paged Segment가 있다.

## Paging
메모리와 프로세스 모두 동일한 크기로 나누어 페이지를 프레임에 매핑 시키는 방법으로, 프로세스의 어느 페이지가 몇 번 프레임에 매핑되는지 알기 위해 Page Table을 프로세스마다 구성한다. 이때, 크기 단위를 프로세스에서는 Page, 메모리에서는 Frame이라 부른다. Paging 기법에서는 일부만 메모리에 올리고 나머지는 Swap 영역(Backing Store)에 저장한다.

* 장점
  * 크기가 모두 동일하므로 외부 조각 없음, 압축 작업 해소
  * 페이지 크기가 작아(4KB이하) 메모리에 올라갈 수 있는 Process 수 증가(동시 수행 수 증가)
* 단점
  * 고정 크기 분할로 프레임내 여유공간이 생기는 내부 조각 발생
  * 주소 변환 절차 복잡

### Page Table
Paging 기법에서 논리 주소를 실제 주소로 변환하기 위한 자료구조로 주로 배열로 구현된다. 프로세스마다 생성되며 Page 수 만큼 Table Entry가 존재해 용량이 커서 Main Memory에 위치하며 때문에 메모리 접근 오버헤드가 생긴다. 즉, 메모리에 접근할 때마다 주소 변환을 위한 테이블 접근과 실제 데이터에 접근으로 2번씩 접근하게 된다. 

Memory 접근 속도를 향상시키기 위해 Associative Register(TLB) 고속의 주소 변환용 캐시 메모리를 사용한다. TLB에는 자주 사용되는 Page Table의 Entry가 저장되고, 메모리 접근 전에 TLB부터 검색하고 있으면 바로 Memory 접근, 없으면 Page Table을 검색함으로서 접근 시간을 단축시킨다. 일반적으로 TLB는 모든 항목을 동시에 확인하는 병렬 탐색이 가능한 연관 레지스터를 사용한다.

### Shared Page

### Page Size

## Segmentation
프로세스 주소 공간을 기능 또는 의미 단위로 나누어 Memory에 올리는 방법으로 크기가 균일하지 않다. 일반적을 Code, Data, Stack 부분이 하나씩 세그먼트로 정의되고, 함수 단위로 나누기도 한다. Paging과 마찬가지로 의미단위로 필요한 부분만 메모리에 올라가게 된다. 
* 장점
  * 내부 조각 없음
  * 논리 단위로 묶여 있으므로 용도에 따라 메모리 접근에 차용 권한을 줄 수 있다.
  * 프로그래밍 용이, 코드 수정 악용 방지
* 단점
  * 동시 수행 Process 수 감소

* Segment Table
* Shared Segment

## Paged Segmentation
세그먼테이션과 페이징 기법의 장점만을 취한 주소 변환 방법. 프로그램을 의미 단위의 세그먼트로 나누지만 각 세그먼트는 여러개의 페이지들로 구성된다. 그리고 메모리에 적재하는 단위는 페이지 단위이다. 그 결과 세그멘테이션 기법의 외부 조각 문제를 해결하고, 세그먼트 단위로 프로세스 간 공유나 프로세스 내 접근 권한 보호가 이루어지도록 함으로써 페이징 기법 약점을 해소한다. 주소 변환을 위해 외부의 Segment Table과 내부의 Page Table, 2단계의 데이블을 이용한다.

# Virtual Memory
프로세스마다 생성되는 **독립적인** 공간으로 0번지 부터 시작된다. 이들 중 일부는 physical memory에 위치하고, 나머지는 디스크 swap area에 존재한다. 프로세스의 주소 공간은 Code, Data, Stack, Heap등으로 구성되며, 메모리로 적재하는 단위에 따라 가상 메모리 기법은 demand paging 방식과 demand segmentation 방식이 있다.

## Demand Paging
요구 페이징이란 프로세스를 구성하는 모든 페이지를 통째로 메모리에 올리는 것이 아니라 당장 사용될 페이지만 올리는 방식을 말한다. 즉, cpu의 요청이 들어왔을 때 해당 페이지를 메모리에 load하는 것이다. 당장 필요한 페이지만을 메모리에 올리기 때문에, **메모리 사용량이 감소**하고 프로세스 전체를 메모리에 올리는 데 들었던 **입출력 오버헤드**도 감소. 이것은 사용되지 않을 영역에 대한 입출력까지 수행하던 기존 방식에 비해 **응답 시간을 단축**시킬 수 있으며, **더 많은 프로세스**를 메모리에 올릴 수 있게 된다. 페이지 중 일부만을 적재할 수 있게 되므로, physical memory 크기 보다 큰 프로그램도 실행할 수 있게 된다.

#### valid-invalid Bit
프로세스의 일부만이 메모리에 적재되므로 어떤 페이지가 메모리에 올라와 있고, 안 올라와 있는지 구별하기 위한 방안으로 valid-invalid bit를 두어 해당 페이지가 메모리에 존재하는지 표시하게 된다. 이 비트는 모든 페이지에 대해 표시되어야 하므로 page table의 각 항목별로 저장된다.

#### page fault
**cpu가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아** invalid로 세팅되어 있는 경우 page fault(페이지 부재)가 일어났다고 한다. 

### Page Replacement
Demand Paging 기법의 **성능**에 가장 큰 영향을 미치는 요소는 **Page Fault 발생 빈도**이다. 페이지 부재가 일어나면, 요청된 페이지를 디스크에서 메모리로 읽어오는 막대한 오버헤드가 발생하기 때문에 **Page Fault를 최소화**한다.

페이지 부재가 발생하면 요청된 페이지를 디스크에서 메모리로 읽어와야 하는데, 메모리에 빈 프레임이 존재하지 않을 수 있다. 이 경우 메모리에 있는 페이지 중 하나를 디스크로 쫓아내서 빈 공간을 확보하는 작업이 필요한데, 이것을 Page Replacement(페이지 교체)라 한다. 페이지 교체를 할 때 어떤 Frame에 있는 Page를 쫓아낼 것인지 결정하는 알고리즘을 Replacement Algorithm(교체 알고리즘)이라 한다. 이 알고리즘은 Page Fault를 최소화하는 것이 목표로 **앞으로 참조될 가능성이 가장 적은 페이지를 쫓아내는** 방안이다. 

정리: 
페이지 부재가 발생하면 페이지를 디스크에서 메모리로 가져와야 하는데, 메모리에 빈 공간이 없을 경우 공간 확보를 위해 페이지 하나를 쫓아내고 이때 앞으로 참조될 가능성이 가장 적은 페이지를 쫓아내야합니다. 이때 쫓아낼 페이지를 선택하는 방법으로 여러 교체 알고를 사용.

## Replacement Algorithm
#### OPT (Optimal Page Replacement)
가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 알고리즘으로 Belady의 최적 알고리즘이라고도 부른다. 
* 장점
  * 알고리즘 중 가장 적은 Page Fault를 보장한다.
* 단점
  * 어떤 순서로 참조될지 미리 알고 있어야 하므로 구현이 어려움. 모든 프로세스의 메모리 참조 계획을 미리 파악할 방법이 없기 때문이다.

#### FIFO 알고리즘
물리 메모리에 온어온 순서대로 교체하는 알고리즘으로 앞으로 참조될 가능성을 고려하지 않는다.
* 장점
  * 구현이 간단하고 이해하기 쉽다.
* 단점
  * 계속 참조가 이루어지는 페이지를 교체해 페이지 부재율을 높일 수 있다.
  * FIFO Anomaly(Belady's Anomaly): 메모리 공간이 늘어나 저장할 수 있는 페이지 프레임 수가 늘어났음에도 페이지 부재율이 더 많이 발생하는 현상

#### LRU 알고리즘
**참조 시점**이 가장 오래된 페이지를 교체하는 알고리즘으로 최근에 참조된 Page가 다시 참조되는 경향을 이용한 것(Time Locality) 
* 장단점
  * 참조 시점의 최근성 반영
  * 장기적인 시간 규모를 보지 못해 page 인기도를 반영 불가

#### LFU 알고리즘
**참조 횟수**가 가장 적은 페이지를 교체하는 알고리즘으로 활발히 사용되는 페이지는 참조 횟수가 앞으로도 많아질 것이라는 가정에서 만들어짐
* 장단점
  * LRU는 직전 참조 시점만을 보지만 LFU는 장기적인 규모에서의 참조 성향을 고려하므로 Page 인기도 반영 가능
  * LRU보다 구현이 복잡

* Paging System에선 LRU, LFU 알고리즘을 사용 못한다.

#### Clock 알고리즘 (LRU 근사 알고리즘)
LRU와 LFU 알고리즘은 페이지의 최근 참조 시각 및 참조 횟수를 소프트웨어적으로 유지해야 하므로 알고리즘 운영에 시간적인 오버헤드가 발생한다. 클럭 알고리즘은 하드웨어 지원을 통해 운영 오버헤드를 줄인 방식이다. 

클럭 알고리즘은 최근에 참조되지 않은 페이지를 교체하는 알고리즘으로 LRU와 달리 참조 시점이 가장 오래되었음을 보장하진 못한다. 하지만 하드웨어적인 지원으로 동작하기 때문에 교체 페이지 선정이 LRU보다 훨씬 빠르다. 교체할 페이지 선정 방법은 페이지 프레임들의 reference bit들을 첫번째 프레임부터 순차적으로 조사해 참조 비트가 0인 페이지를 찾아 교체한다.

## Page Frame Allocation
여러개 프로세스가 동시에 수행되는 상황에서 각 프로세스에 얼만큼의 메모리 공간(Page Frame)을 할당할지 결정해야 한다. 모든 프로세스에 똑같은 갯수를 할당하는 방식과 프로세스 크기에 비례하여 할당하는 방식, 그리고 프로세스의 우선순위에 따라 할당하는 방식이 있다. 이 방식은 프로세스 중에서 당장 cpu에서 실행될 프로세스와 그렇지 않은 프로세스를 구분하여 전자 쪽에 더 많은 페이지 프레임을 할당하는 방식이다.






